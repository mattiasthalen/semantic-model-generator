---
phase: 07-fabric-rest-api-integration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/semantic_model_generator/fabric/__init__.py
  - src/semantic_model_generator/fabric/auth.py
  - src/semantic_model_generator/fabric/resolution.py
  - src/semantic_model_generator/fabric/packaging.py
  - tests/fabric/__init__.py
  - tests/fabric/test_auth.py
  - tests/fabric/test_resolution.py
  - tests/fabric/test_packaging.py
autonomous: true

must_haves:
  truths:
    - "Token acquisition returns a bearer token string for Fabric API scope"
    - "Workspace name resolves to GUID via Fabric list API; workspace GUID passes through unchanged"
    - "Lakehouse/warehouse name resolves to GUID within a workspace; GUID passes through unchanged"
    - "Direct Lake URL is constructed from workspace and lakehouse GUIDs"
    - "TMDL dict[str, str] is base64-encoded into Fabric definition parts array"
    - "is_guid correctly identifies valid UUIDs and rejects non-UUID strings"
  artifacts:
    - path: "src/semantic_model_generator/fabric/auth.py"
      provides: "get_fabric_token() returning bearer token string"
      exports: ["get_fabric_token"]
    - path: "src/semantic_model_generator/fabric/resolution.py"
      provides: "Name-to-GUID resolution and Direct Lake URL construction"
      exports: ["resolve_workspace_id", "resolve_lakehouse_id", "resolve_direct_lake_url", "build_direct_lake_url", "is_guid"]
    - path: "src/semantic_model_generator/fabric/packaging.py"
      provides: "TMDL base64 encoding and Fabric API payload assembly"
      exports: ["package_tmdl_for_fabric"]
    - path: "tests/fabric/test_auth.py"
      provides: "Auth module tests"
    - path: "tests/fabric/test_resolution.py"
      provides: "Resolution module tests"
    - path: "tests/fabric/test_packaging.py"
      provides: "Packaging module tests"
  key_links:
    - from: "src/semantic_model_generator/fabric/auth.py"
      to: "azure.identity.DefaultAzureCredential"
      via: "get_token with Fabric API scope"
      pattern: "get_token.*api\\.fabric\\.microsoft\\.com"
    - from: "src/semantic_model_generator/fabric/resolution.py"
      to: "requests"
      via: "HTTP GET to Fabric list APIs"
      pattern: "requests\\.(get|post)"
    - from: "src/semantic_model_generator/fabric/packaging.py"
      to: "base64"
      via: "b64encode for TMDL content"
      pattern: "base64\\.b64encode"
---

<objective>
Create the Fabric REST API foundation modules: authentication (bearer token acquisition), name-to-GUID resolution (workspace, lakehouse/warehouse), Direct Lake URL construction, and TMDL packaging (base64 encoding into Fabric API payload format).

Purpose: These are the building blocks Plan 07-02 needs for actual deployment. Each module has clear input/output contracts suitable for TDD. The `requests` dependency is added to pyproject.toml here since resolution needs it.

Output: Four source modules under `src/semantic_model_generator/fabric/`, three test files, updated pyproject.toml.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-fabric-rest-api-integration/07-RESEARCH.md

@src/semantic_model_generator/schema/connection.py
@src/semantic_model_generator/tmdl/generate.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Write failing tests for auth, resolution, and packaging</name>
  <files>
    pyproject.toml
    src/semantic_model_generator/fabric/__init__.py
    src/semantic_model_generator/fabric/auth.py
    src/semantic_model_generator/fabric/resolution.py
    src/semantic_model_generator/fabric/packaging.py
    tests/fabric/__init__.py
    tests/fabric/test_auth.py
    tests/fabric/test_resolution.py
    tests/fabric/test_packaging.py
  </files>
  <action>
    **Step 1: Add `requests` to pyproject.toml dependencies.**
    Add `"requests>=2.31"` to the `dependencies` list in pyproject.toml. Also add a mypy override for `requests` to `ignore_missing_imports = true` (requests has stubs but they may not be installed).

    **Step 2: Create stub modules under `src/semantic_model_generator/fabric/`.**

    Create `fabric/__init__.py` with exports:
    - From auth: `get_fabric_token`
    - From resolution: `resolve_workspace_id`, `resolve_lakehouse_id`, `resolve_direct_lake_url`, `build_direct_lake_url`, `is_guid`
    - From packaging: `package_tmdl_for_fabric`

    Create `fabric/auth.py` with stub:
    ```python
    def get_fabric_token() -> str:
        raise NotImplementedError
    ```

    Create `fabric/resolution.py` with stubs:
    ```python
    def is_guid(value: str) -> bool:
        raise NotImplementedError

    def build_direct_lake_url(workspace_id: str, lakehouse_id: str) -> str:
        raise NotImplementedError

    def resolve_workspace_id(workspace_name: str, token: str) -> str:
        raise NotImplementedError

    def resolve_lakehouse_id(workspace_id: str, lakehouse_name: str, token: str, item_type: str = "Lakehouse") -> str:
        raise NotImplementedError

    def resolve_direct_lake_url(workspace: str, lakehouse: str, token: str, item_type: str = "Lakehouse") -> str:
        raise NotImplementedError
    ```

    Create `fabric/packaging.py` with stub:
    ```python
    def package_tmdl_for_fabric(tmdl_files: dict[str, str]) -> dict[str, list[dict[str, str]]]:
        raise NotImplementedError
    ```

    **Step 3: Create `tests/fabric/__init__.py`** (empty).

    **Step 4: Write `tests/fabric/test_auth.py`** with tests (all using `unittest.mock.patch`):
    - `test_get_fabric_token_returns_string`: Mock DefaultAzureCredential, verify returns token.token string
    - `test_get_fabric_token_uses_correct_scope`: Verify get_token called with `"https://api.fabric.microsoft.com/.default"`
    - `test_get_fabric_token_creates_credential`: Verify DefaultAzureCredential() is instantiated

    **Step 5: Write `tests/fabric/test_resolution.py`** with tests:

    `is_guid` tests (pure, no mocks):
    - `test_is_guid_valid_lowercase`: `"a1b2c3d4-e5f6-7890-abcd-ef1234567890"` -> True
    - `test_is_guid_valid_uppercase`: `"A1B2C3D4-E5F6-7890-ABCD-EF1234567890"` -> True
    - `test_is_guid_invalid_short`: `"not-a-guid"` -> False
    - `test_is_guid_invalid_format`: `"a1b2c3d4e5f67890abcdef1234567890"` (no dashes) -> False
    - `test_is_guid_empty`: `""` -> False

    `build_direct_lake_url` tests (pure, no mocks):
    - `test_build_direct_lake_url`: Returns `"https://onelake.dfs.fabric.microsoft.com/{workspace_id}/{lakehouse_id}"`

    `resolve_workspace_id` tests (mock `requests.get`):
    - `test_resolve_workspace_id_found`: Mock returns JSON with matching workspace, verify correct GUID returned
    - `test_resolve_workspace_id_not_found`: Mock returns empty list, verify `ValueError` raised with workspace name in message
    - `test_resolve_workspace_id_multiple_matches`: Mock returns 2 workspaces with same name, verify `ValueError`
    - `test_resolve_workspace_id_uses_bearer_token`: Verify Authorization header contains `"Bearer {token}"`

    `resolve_lakehouse_id` tests (mock `requests.get`):
    - `test_resolve_lakehouse_id_found`: Mock returns matching lakehouse
    - `test_resolve_lakehouse_id_not_found`: `ValueError` raised
    - `test_resolve_lakehouse_id_warehouse_type`: Verify endpoint uses `/warehouses` when `item_type="Warehouse"`
    - `test_resolve_lakehouse_id_lakehouse_type`: Verify endpoint uses `/lakehouses` when `item_type="Lakehouse"`

    `resolve_direct_lake_url` tests (mock resolution functions):
    - `test_resolve_direct_lake_url_with_names`: Both workspace and lakehouse are names, verify resolution called and URL returned
    - `test_resolve_direct_lake_url_with_guids`: Both are GUIDs, verify no resolution API calls, URL returned directly
    - `test_resolve_direct_lake_url_mixed`: Workspace is name, lakehouse is GUID

    **Step 6: Write `tests/fabric/test_packaging.py`** with tests (pure, no mocks):
    - `test_package_single_file`: One TMDL file -> parts array with 1 element
    - `test_package_multiple_files`: Three files -> parts array with 3 elements
    - `test_package_base64_encoding`: Verify content is correctly base64 encoded (decode and compare)
    - `test_package_utf8_encoding`: Content with non-ASCII chars (e.g., umlauts) correctly encoded
    - `test_package_path_preserved`: Verify `path` field matches input dict key
    - `test_package_payload_type`: All parts have `"payloadType": "InlineBase64"`
    - `test_package_empty_dict`: Empty input -> empty parts array
    - `test_package_structure`: Result has `"parts"` key containing a list

    **All tests must fail with `NotImplementedError` from stubs.**

    Run `make test` to confirm all existing tests pass AND new tests fail with NotImplementedError (not import errors or syntax errors).
  </action>
  <verify>
    `make test` shows all new tests failing with NotImplementedError (not import or syntax errors). Existing 299 tests still pass. `make lint` passes (ruff clean). `make typecheck` passes (mypy clean with new stubs).
  </verify>
  <done>
    Stub modules exist, exports work, test files import correctly, all new tests fail with NotImplementedError, all 299 existing tests pass, lint and typecheck clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement auth, resolution, and packaging modules</name>
  <files>
    src/semantic_model_generator/fabric/auth.py
    src/semantic_model_generator/fabric/resolution.py
    src/semantic_model_generator/fabric/packaging.py
  </files>
  <action>
    **Implement `fabric/auth.py`:**

    ```python
    from azure.identity import DefaultAzureCredential

    FABRIC_API_SCOPE = "https://api.fabric.microsoft.com/.default"

    def get_fabric_token() -> str:
        """Acquire bearer token for Fabric REST API.

        Uses DefaultAzureCredential which supports multiple credential sources
        (managed identity, CLI, environment variables, etc.).

        Returns:
            Bearer token string (not including 'Bearer ' prefix).
        """
        credential = DefaultAzureCredential()
        token = credential.get_token(FABRIC_API_SCOPE)
        return token.token
    ```

    **Implement `fabric/resolution.py`:**

    - `FABRIC_API_BASE = "https://api.fabric.microsoft.com/v1"`

    - `is_guid(value: str) -> bool`: Use `re.match` with pattern `^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$` on `value.lower()`. Return False for empty strings.

    - `_call_fabric_api(endpoint: str, token: str) -> dict`: Internal helper. `requests.get(f"{FABRIC_API_BASE}/{endpoint}", headers={"Authorization": f"Bearer {token}", "Content-Type": "application/json"})`. Call `response.raise_for_status()`. Return `response.json()`.

    - `build_direct_lake_url(workspace_id: str, lakehouse_id: str) -> str`: Return `f"https://onelake.dfs.fabric.microsoft.com/{workspace_id}/{lakehouse_id}"`.

    - `resolve_workspace_id(workspace_name: str, token: str) -> str`: Call `_call_fabric_api("workspaces", token)`. Filter `response["value"]` by `displayName == workspace_name`. Raise `ValueError` if 0 or >1 matches. Return `matches[0]["id"]`.

    - `resolve_lakehouse_id(workspace_id: str, lakehouse_name: str, token: str, item_type: str = "Lakehouse") -> str`: Build endpoint from `item_type` ("Lakehouse" -> `workspaces/{workspace_id}/lakehouses`, "Warehouse" -> `workspaces/{workspace_id}/warehouses`). Raise `ValueError` for unsupported item_type. Call API, filter by displayName, raise ValueError if 0 or >1 matches. Return match id.

    - `resolve_direct_lake_url(workspace: str, lakehouse: str, token: str, item_type: str = "Lakehouse") -> str`: Check `is_guid(workspace)` to decide whether to resolve or use directly. Same for lakehouse. Call `build_direct_lake_url` with resolved GUIDs.

    **Implement `fabric/packaging.py`:**

    ```python
    import base64

    def package_tmdl_for_fabric(tmdl_files: dict[str, str]) -> dict[str, list[dict[str, str]]]:
        """Package TMDL files as base64-encoded definition parts for Fabric API.

        Args:
            tmdl_files: Dict mapping relative paths to TMDL content
                        (from generate_all_tmdl()).

        Returns:
            Definition object with "parts" key containing list of
            {path, payload, payloadType} dicts.
        """
        parts: list[dict[str, str]] = []
        for path, content in tmdl_files.items():
            payload_base64 = base64.b64encode(content.encode("utf-8")).decode("ascii")
            parts.append({
                "path": path,
                "payload": payload_base64,
                "payloadType": "InlineBase64",
            })
        return {"parts": parts}
    ```

    Run `make check` to verify all tests pass (new + existing), lint clean, typecheck clean.
  </action>
  <verify>
    `make check` passes: all tests pass (new auth/resolution/packaging tests + existing 299), ruff clean, mypy clean. Specifically verify: `pytest tests/fabric/ -v` shows all new tests passing.
  </verify>
  <done>
    All auth, resolution, and packaging functions implemented and tested. Token acquisition uses DefaultAzureCredential with correct Fabric scope. Name resolution handles both name and GUID inputs. Packaging correctly base64-encodes all TMDL content with InlineBase64 payloadType. All quality gates pass.
  </done>
</task>

</tasks>

<verification>
1. `make check` passes (lint + typecheck + all tests)
2. `pytest tests/fabric/ -v` shows all new tests passing
3. `python -c "from semantic_model_generator.fabric import get_fabric_token, resolve_workspace_id, resolve_lakehouse_id, resolve_direct_lake_url, build_direct_lake_url, is_guid, package_tmdl_for_fabric; print('All imports OK')"` succeeds
4. `python -c "from semantic_model_generator.fabric.packaging import package_tmdl_for_fabric; import base64; result = package_tmdl_for_fabric({'test.tmdl': 'hello'}); assert base64.b64decode(result['parts'][0]['payload']).decode() == 'hello'; print('Base64 roundtrip OK')"` succeeds
</verification>

<success_criteria>
- `requests` added to pyproject.toml dependencies
- `fabric/` package exists with auth, resolution, packaging modules
- All functions have correct type annotations and docstrings
- Token acquisition uses `https://api.fabric.microsoft.com/.default` scope
- Resolution functions accept both names and GUIDs (GUID passthrough via is_guid)
- Packaging produces valid base64 with UTF-8 encoding
- All tests pass with mocks (no actual API calls in tests)
- `make check` clean (lint + typecheck + tests)
</success_criteria>

<output>
After completion, create `.planning/phases/07-fabric-rest-api-integration/07-01-SUMMARY.md`
</output>
