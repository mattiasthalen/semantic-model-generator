---
phase: 03-schema-discovery-classification
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/semantic_model_generator/domain/types.py
  - src/semantic_model_generator/domain/__init__.py
  - src/semantic_model_generator/schema/__init__.py
  - src/semantic_model_generator/schema/filtering.py
  - src/semantic_model_generator/schema/classification.py
  - tests/schema/__init__.py
  - tests/schema/test_filtering.py
  - tests/schema/test_classification.py
autonomous: true

must_haves:
  truths:
    - "Tables can be filtered by include list only, exclude list only, or both combined"
    - "Include filtering keeps only tables whose names match at least one include pattern"
    - "Exclude filtering removes tables whose names match any exclude pattern"
    - "When both include and exclude are specified, include is applied first then exclude"
    - "Passing no include or exclude returns all tables unchanged"
    - "Tables with exactly 1 key column (matching user-supplied prefixes) are classified as dimension"
    - "Tables with 2+ key columns are classified as fact"
    - "Tables with 0 key columns are classified as unclassified"
    - "Key prefix matching is case-sensitive using startswith()"
    - "TableClassification enum has exactly three members: DIMENSION, FACT, UNCLASSIFIED"
  artifacts:
    - path: "src/semantic_model_generator/domain/types.py"
      provides: "TableClassification StrEnum added to existing domain types"
      contains: "class TableClassification"
      exports: ["TableClassification"]
    - path: "src/semantic_model_generator/schema/filtering.py"
      provides: "Pure functions for table include/exclude filtering"
      exports: ["filter_tables"]
    - path: "src/semantic_model_generator/schema/classification.py"
      provides: "Pure functions for fact/dimension classification by key column count"
      exports: ["classify_table", "classify_tables"]
    - path: "tests/schema/test_filtering.py"
      provides: "Tests for table filtering with include, exclude, both, and neither"
    - path: "tests/schema/test_classification.py"
      provides: "Tests for table classification by key column count"
  key_links:
    - from: "src/semantic_model_generator/schema/classification.py"
      to: "src/semantic_model_generator/domain/types.py"
      via: "imports TableClassification, ColumnMetadata, TableMetadata"
      pattern: "from semantic_model_generator\\.domain\\.types import"
    - from: "src/semantic_model_generator/schema/filtering.py"
      to: "src/semantic_model_generator/domain/types.py"
      via: "imports TableMetadata"
      pattern: "from semantic_model_generator\\.domain\\.types import TableMetadata"
---

<objective>
Implement table filtering (include/exclude lists) and fact/dimension classification (key column counting) as pure TDD functions. Add TableClassification enum to domain types. These are the decision-making functions that downstream phases depend on for correct star-schema modeling.

Purpose: Filtering determines which tables enter the semantic model; classification determines their role (dimension vs fact). Both are pure functions with clear input/output contracts, ideal for TDD. Getting classification wrong produces an incorrect semantic model.
Output: Tested filtering.py and classification.py modules in new schema/ package, TableClassification enum in domain/types.py.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-schema-discovery-classification/03-RESEARCH.md
@.planning/phases/02-domain-types-core-utilities/02-01-SUMMARY.md
@src/semantic_model_generator/domain/types.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD table filtering -- include/exclude list pure functions</name>
  <files>
    src/semantic_model_generator/schema/__init__.py
    src/semantic_model_generator/schema/filtering.py
    tests/schema/__init__.py
    tests/schema/test_filtering.py
  </files>
  <action>
Create the phase branch from main:
```bash
git checkout main && git pull && git checkout -b gsd/phase-03-schema-discovery-classification
```

Create directory structure:
- src/semantic_model_generator/schema/__init__.py (docstring only: """Schema discovery and classification.""")
- tests/schema/__init__.py (empty)

RED phase -- Write tests/schema/test_filtering.py FIRST with these test cases:

Use pytest with ColumnMetadata and TableMetadata from semantic_model_generator.domain.types. Create helper fixtures that build TableMetadata objects for testing (e.g., a fixture that creates tables named "DimCustomer", "DimProduct", "FactSales", "FactOrders", "StagingTemp").

1. Include-only filtering:
   - include=["DimCustomer", "FactSales"] keeps only those 2 tables
   - include=["DimCustomer"] keeps only DimCustomer
   - include=["NonExistent"] returns empty list
   - include=[] (empty list) returns empty list (no tables match)

2. Exclude-only filtering:
   - exclude=["StagingTemp"] removes StagingTemp, keeps others
   - exclude=["DimCustomer", "FactSales"] removes both, keeps others
   - exclude=["NonExistent"] returns all tables (nothing matched)
   - exclude=[] (empty list) returns all tables

3. Combined include + exclude:
   - include=["DimCustomer", "DimProduct", "FactSales"], exclude=["DimProduct"] returns DimCustomer + FactSales (include first, then exclude)

4. Neither (no filtering):
   - include=None, exclude=None returns all tables unchanged
   - Verify returned list preserves input order

5. Edge cases:
   - Empty input list returns empty list regardless of include/exclude
   - Case-sensitive: include=["dimcustomer"] does NOT match "DimCustomer"

The function signature to test:
```python
def filter_tables(
    tables: Sequence[TableMetadata],
    include: Sequence[str] | None = None,
    exclude: Sequence[str] | None = None,
) -> list[TableMetadata]:
```

Filtering matches on `table.table_name` using exact string equality (not pattern/glob matching). This is simple name matching per REQ-03.

Run tests -- they MUST fail (no implementation yet).
Commit: "test(03-01): add failing tests for table filtering"

GREEN phase -- Create src/semantic_model_generator/schema/filtering.py:

```python
"""Table filtering by include and exclude lists."""

from collections.abc import Sequence
from semantic_model_generator.domain.types import TableMetadata


def filter_tables(
    tables: Sequence[TableMetadata],
    include: Sequence[str] | None = None,
    exclude: Sequence[str] | None = None,
) -> list[TableMetadata]:
    """Filter tables by include and/or exclude lists.

    - If include is not None: only tables whose table_name is in include are kept
    - If exclude is not None: tables whose table_name is in exclude are removed
    - Both can be combined: include is applied first, then exclude
    - If both are None: all tables are returned unchanged
    """
    result: Sequence[TableMetadata] = tables

    if include is not None:
        include_set = set(include)
        result = [t for t in result if t.table_name in include_set]

    if exclude is not None:
        exclude_set = set(exclude)
        result = [t for t in result if t.table_name not in exclude_set]

    return list(result)
```

Update schema/__init__.py to re-export filter_tables.

Run tests -- they MUST pass. Run `make check` to confirm all green.
Commit: "feat(03-01): implement table filtering"
  </action>
  <verify>
    1. `make test` passes with all filtering tests green
    2. `make check` passes (lint + typecheck + test)
    3. `python -c "from semantic_model_generator.schema.filtering import filter_tables; print('OK')"` succeeds
  </verify>
  <done>
    filter_tables function correctly handles include-only, exclude-only, combined, and no-filter scenarios. Case-sensitive exact name matching. Empty inputs handled gracefully. All tests pass including edge cases.
  </done>
</task>

<task type="auto">
  <name>Task 2: TDD fact/dimension classification -- key column counting</name>
  <files>
    src/semantic_model_generator/domain/types.py
    src/semantic_model_generator/domain/__init__.py
    src/semantic_model_generator/schema/classification.py
    src/semantic_model_generator/schema/__init__.py
    tests/schema/test_classification.py
  </files>
  <action>
RED phase -- First, add the TableClassification enum to domain/types.py (needed by tests):

```python
class TableClassification(StrEnum):
    """Classification of a warehouse table in star schema."""
    DIMENSION = "dimension"
    FACT = "fact"
    UNCLASSIFIED = "unclassified"
```

Add it AFTER TmdlDataType in domain/types.py. Update domain/__init__.py to re-export TableClassification.

Then write tests/schema/test_classification.py FIRST:

Create helper functions that build ColumnMetadata tuples for testing. Use key prefixes like ["SK_", "FK_"] (typical surrogate key / foreign key prefixes).

1. TableClassification enum tests:
   - Has exactly 3 members
   - DIMENSION == "dimension", FACT == "fact", UNCLASSIFIED == "unclassified"
   - Is a StrEnum subclass

2. classify_table tests (single table classification):
   Function signature: `classify_table(columns: Sequence[ColumnMetadata], key_prefixes: Sequence[str]) -> TableClassification`

   - Table with 1 column matching key prefix -> DIMENSION
     Example: columns=["SK_CustomerID", "Name", "Email"], prefixes=["SK_", "FK_"] -> DIMENSION (1 key: SK_CustomerID)
   - Table with 2+ columns matching key prefixes -> FACT
     Example: columns=["SK_SalesID", "FK_CustomerID", "FK_ProductID", "Amount"], prefixes=["SK_", "FK_"] -> FACT (3 keys)
   - Table with 0 columns matching any prefix -> UNCLASSIFIED
     Example: columns=["Name", "Value", "Description"], prefixes=["SK_", "FK_"] -> UNCLASSIFIED
   - Table with exactly 2 key columns -> FACT
     Example: columns=["FK_CustomerID", "FK_ProductID"], prefixes=["FK_"] -> FACT
   - Key prefix matching is case-sensitive: "sk_CustomerID" does NOT match prefix "SK_"
   - Multiple prefixes: columns=["PK_ID", "FK_CustID"], prefixes=["PK_", "FK_"] -> FACT (2 keys)
   - Single prefix: columns=["FK_CustID"], prefixes=["FK_"] -> DIMENSION (1 key)
   - Empty key_prefixes list -> UNCLASSIFIED (no columns can match)
   - Empty columns tuple -> UNCLASSIFIED

3. classify_tables tests (batch classification):
   Function signature: `classify_tables(tables: Sequence[TableMetadata], key_prefixes: Sequence[str]) -> dict[tuple[str, str], TableClassification]`

   Returns dict mapping (schema_name, table_name) -> classification.

   - Classify a mix of dimension, fact, and unclassified tables
   - Empty input returns empty dict
   - Key is (schema_name, table_name) tuple for uniqueness across schemas

Run tests -- they MUST fail.
Commit: "test(03-01): add failing tests for table classification"

GREEN phase -- Create src/semantic_model_generator/schema/classification.py:

```python
"""Table classification by key column count.

Classifies warehouse tables as dimension, fact, or unclassified
based on the number of columns matching user-supplied key prefixes.

Per REQ-04:
- 1 key column -> dimension (single primary/surrogate key)
- 2+ key columns -> fact (composite foreign keys)
- 0 key columns -> unclassified
"""

from collections.abc import Sequence
from semantic_model_generator.domain.types import (
    ColumnMetadata,
    TableClassification,
    TableMetadata,
)


def classify_table(
    columns: Sequence[ColumnMetadata],
    key_prefixes: Sequence[str],
) -> TableClassification:
    """Classify a single table by counting key columns.

    Key columns are those whose name starts with any of the given prefixes.
    Matching is case-sensitive (per research recommendation).
    """
    key_count = sum(
        1 for col in columns
        if any(col.name.startswith(prefix) for prefix in key_prefixes)
    )

    if key_count == 1:
        return TableClassification.DIMENSION
    elif key_count >= 2:
        return TableClassification.FACT
    else:
        return TableClassification.UNCLASSIFIED


def classify_tables(
    tables: Sequence[TableMetadata],
    key_prefixes: Sequence[str],
) -> dict[tuple[str, str], TableClassification]:
    """Classify multiple tables, returning a mapping of (schema, table) -> classification."""
    return {
        (t.schema_name, t.table_name): classify_table(t.columns, key_prefixes)
        for t in tables
    }
```

Update schema/__init__.py to re-export classify_table, classify_tables, and TableClassification.

Run tests -- they MUST pass. Run `make check` to confirm all green.
Commit: "feat(03-01): implement table classification"
  </action>
  <verify>
    1. `make test` passes with all classification tests green
    2. `make check` passes (lint + typecheck + test)
    3. `python -c "from semantic_model_generator.domain.types import TableClassification; assert TableClassification.DIMENSION == 'dimension'"` succeeds
    4. `python -c "from semantic_model_generator.schema.classification import classify_table; print('OK')"` succeeds
  </verify>
  <done>
    TableClassification enum with DIMENSION/FACT/UNCLASSIFIED values added to domain types. classify_table correctly counts key columns by prefix matching: 1=dimension, 2+=fact, 0=unclassified. classify_tables provides batch classification returning (schema, table)->classification dict. Case-sensitive prefix matching via startswith(). All tests pass.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `make check` passes with zero errors
2. All filtering tests pass (include, exclude, combined, no-filter, edge cases)
3. All classification tests pass (dimension, fact, unclassified, case sensitivity, batch)
4. `mypy src/` passes in strict mode
5. TableClassification importable: `from semantic_model_generator.domain.types import TableClassification`
6. Filtering importable: `from semantic_model_generator.schema.filtering import filter_tables`
7. Classification importable: `from semantic_model_generator.schema.classification import classify_table, classify_tables`
8. No external dependencies added (stdlib only for this plan)
</verification>

<success_criteria>
- filter_tables correctly handles include-only, exclude-only, combined, and no-filter scenarios with exact name matching
- TableClassification enum has DIMENSION, FACT, UNCLASSIFIED members
- classify_table correctly classifies: 1 key=dimension, 2+ keys=fact, 0 keys=unclassified
- Key prefix matching is case-sensitive via startswith()
- All tests written BEFORE implementation (TDD commits prove RED then GREEN)
- make check passes (lint + typecheck + test)
- Zero external dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/03-schema-discovery-classification/03-01-SUMMARY.md`
</output>
