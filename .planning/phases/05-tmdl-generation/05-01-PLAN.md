---
phase: 05-tmdl-generation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/semantic_model_generator/tmdl/__init__.py
  - src/semantic_model_generator/tmdl/generate.py
  - tests/tmdl/__init__.py
  - tests/tmdl/test_generate.py
autonomous: true

must_haves:
  truths:
    - "database.tmdl contains 'database' header and compatibilityLevel 1604"
    - "model.tmdl contains culture en-US, ref table lines for all tables, dimensions sorted before facts"
    - "expressions.tmdl contains DirectLake expression with configurable catalog name and en-US locale"
    - "Each table .tmdl has column definitions with correct TMDL data types and deterministic lineageTag UUIDs"
    - "Each table .tmdl has a DirectLake partition referencing the source schema and entity"
    - "Column sections list key columns first, then remaining columns alphabetically"
    - "All generated TMDL passes whitespace validation (tabs only, no spaces)"
  artifacts:
    - path: "src/semantic_model_generator/tmdl/generate.py"
      provides: "TMDL generation functions for database, model, expressions, columns, partitions, tables"
      exports: ["generate_database_tmdl", "generate_model_tmdl", "generate_expressions_tmdl", "generate_column_tmdl", "generate_partition_tmdl", "generate_table_tmdl"]
    - path: "src/semantic_model_generator/tmdl/__init__.py"
      provides: "Package exports for tmdl module"
    - path: "tests/tmdl/test_generate.py"
      provides: "TDD tests for all TMDL generation functions"
  key_links:
    - from: "src/semantic_model_generator/tmdl/generate.py"
      to: "src/semantic_model_generator/utils/whitespace.py"
      via: "indent_tmdl and validate_tmdl_indentation imports"
      pattern: "from semantic_model_generator\\.utils\\.whitespace import"
    - from: "src/semantic_model_generator/tmdl/generate.py"
      to: "src/semantic_model_generator/utils/identifiers.py"
      via: "quote_tmdl_identifier import"
      pattern: "from semantic_model_generator\\.utils\\.identifiers import"
    - from: "src/semantic_model_generator/tmdl/generate.py"
      to: "src/semantic_model_generator/utils/uuid_gen.py"
      via: "generate_deterministic_uuid import"
      pattern: "from semantic_model_generator\\.utils\\.uuid_gen import"
    - from: "src/semantic_model_generator/tmdl/generate.py"
      to: "src/semantic_model_generator/utils/type_mapping.py"
      via: "map_sql_type_to_tmdl import for column data types"
      pattern: "from semantic_model_generator\\.utils\\.type_mapping import"
    - from: "src/semantic_model_generator/tmdl/generate.py"
      to: "src/semantic_model_generator/domain/types.py"
      via: "imports TableMetadata, ColumnMetadata, TableClassification, Relationship"
      pattern: "from semantic_model_generator\\.domain\\.types import"
---

<objective>
Create the core TMDL generation functions: database.tmdl, model.tmdl, expressions.tmdl, and per-table .tmdl files with column definitions and DirectLake partitions.

Purpose: These are the building blocks for generating a complete TMDL semantic model folder. Each function produces a string of valid TMDL content that passes whitespace validation.

Output: `src/semantic_model_generator/tmdl/generate.py` with tested, composable generation functions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-tmdl-generation/05-CONTEXT.md
@.planning/phases/05-tmdl-generation/05-RESEARCH.md
@src/semantic_model_generator/domain/types.py
@src/semantic_model_generator/utils/whitespace.py
@src/semantic_model_generator/utils/identifiers.py
@src/semantic_model_generator/utils/uuid_gen.py
@src/semantic_model_generator/utils/type_mapping.py
@src/semantic_model_generator/schema/classification.py
@tests/schema/test_relationships.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Write failing tests for TMDL generation functions</name>
  <files>
    tests/tmdl/__init__.py
    tests/tmdl/test_generate.py
    src/semantic_model_generator/tmdl/__init__.py
    src/semantic_model_generator/tmdl/generate.py
  </files>
  <action>
Create the tmdl package directories and stub module.

**Create `src/semantic_model_generator/tmdl/__init__.py`** - empty package init.

**Create `src/semantic_model_generator/tmdl/generate.py`** - stub module with function signatures that raise NotImplementedError:
- `generate_database_tmdl() -> str`
- `generate_model_tmdl(model_name: str, table_names: Sequence[str], classifications: dict[tuple[str, str], TableClassification]) -> str` - takes model name, sorted table list, and classifications for dimension-first sorting
- `generate_expressions_tmdl(catalog_name: str) -> str` - en-US locale hardcoded per user decision
- `generate_column_tmdl(column: ColumnMetadata, table_qualified_name: str) -> str` - generates TMDL for one column with dataType, lineageTag, summarizeBy:none, sourceColumn
- `generate_partition_tmdl(table: TableMetadata, partition_name: str) -> str` - DirectLake partition with mode:directLake, entityName, schemaName, expressionSource
- `generate_table_tmdl(table: TableMetadata, classification: TableClassification, key_prefixes: Sequence[str], catalog_name: str) -> str` - composes column + partition sections into full table TMDL

All stubs should have correct type hints importing from domain.types.

**Create `tests/tmdl/__init__.py`** - empty.

**Create `tests/tmdl/test_generate.py`** - comprehensive tests:

Use helper functions to create test fixtures (same pattern as test_relationships.py: `make_column`, `make_table`).

Test `generate_database_tmdl`:
- Output contains "database" as first line
- Output contains tab + "compatibilityLevel: 1604"
- Output passes validate_tmdl_indentation (no errors)

Test `generate_model_tmdl`:
- Output starts with `model Model`
- Contains `culture: en-US` (per user decision: locale hardcoded to en-US)
- Contains `defaultPowerBIDataSourceVersion: powerBI_V3`
- Contains `discourageImplicitMeasures`
- Contains `ref table` lines for each table
- Dimension tables appear before fact tables in ref table list (per user decision)
- Within same classification, tables sorted by (schema_name, table_name)
- Table names with special characters are quoted via quote_tmdl_identifier
- Passes whitespace validation

Test `generate_expressions_tmdl`:
- Output contains `expression 'DirectLake - {catalog}'` (with actual catalog name)
- Contains `AzureStorage.DataLake` reference
- Contains deterministic lineageTag UUID
- Contains `annotation PBI_IncludeFutureArtifacts = False`
- Uses en-US locale (not Swedish "Kalla" but English "Source" - per user decision to use en-US)
- Passes whitespace validation

Test `generate_column_tmdl`:
- Output starts with tab + `column` + quoted identifier
- Contains `dataType:` with correct TMDL type from map_sql_type_to_tmdl
- Contains `lineageTag:` with deterministic UUID
- Contains `summarizeBy: none` (per research recommendation)
- Contains `sourceColumn:` with original column name
- Passes whitespace validation
- Test with a column name containing spaces (should be quoted)
- Test with a simple column name (no quoting needed)

Test `generate_partition_tmdl`:
- Output contains `partition` + quoted name + `= entity`
- Contains `mode: directLake`
- Contains `entityName:` with table name
- Contains `schemaName:` with schema name
- Contains `expressionSource: 'DirectLake - {catalog}'`
- Passes whitespace validation

Test `generate_table_tmdl`:
- Output starts with `table` + quoted identifier
- Contains `lineageTag:` with deterministic UUID
- Contains all column sections
- Contains partition section
- Key columns appear before non-key columns (per user decision)
- Non-key columns sorted alphabetically by name (per user decision)
- Passes whitespace validation
- Test with a table having both key and non-key columns (e.g., ID_Customer, Name, City) with key_prefixes=["ID_"]
- Column order: ID_Customer first, then City, Name (alphabetical)

Test determinism:
- Call generate_table_tmdl twice with same input, assert output is identical (byte-for-byte)
- Call generate_model_tmdl twice with same input, assert output is identical

Run `make check` - all NEW tests should FAIL (NotImplementedError), all 179 existing tests should PASS.
  </action>
  <verify>
`make check` runs; new tests fail with NotImplementedError, existing 179 tests pass. Count new test functions in test_generate.py.
  </verify>
  <done>Test file exists with comprehensive tests covering all 6 generation functions. All new tests fail (RED). All existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement TMDL generation functions</name>
  <files>
    src/semantic_model_generator/tmdl/generate.py
    src/semantic_model_generator/tmdl/__init__.py
  </files>
  <action>
Implement all 6 functions in `src/semantic_model_generator/tmdl/generate.py`. Use Python f-strings only (no Jinja2) per user decision. Import and use Phase 2 utilities: `indent_tmdl`, `validate_tmdl_indentation`, `quote_tmdl_identifier`, `generate_deterministic_uuid`, `map_sql_type_to_tmdl`.

**`generate_database_tmdl() -> str`:**
```
database
\tcompatibilityLevel: 1604
```
Simple static content. Validate with `validate_tmdl_indentation` before returning.

**`generate_model_tmdl(model_name, table_names, classifications) -> str`:**
- Header: `model Model`
- Properties: culture: en-US, defaultPowerBIDataSourceVersion: powerBI_V3, discourageImplicitMeasures
- Sort table_names: dimensions first, then facts, then unclassified. Within each group sort by (schema_name, table_name) tuple. Extract schema/table from qualified name "schema.table" for sorting.
- For each table: `ref table {quote_tmdl_identifier(name)}`
- Validate with `validate_tmdl_indentation` before returning.

**`generate_expressions_tmdl(catalog_name: str) -> str`:**
- Expression definition with DirectLake connection to catalog
- Use en-US locale per user decision: variable name "Source" (NOT Swedish "Kalla")
- Pattern from reference notebook adapted to en-US:
```
expression 'DirectLake - {catalog_name}' =
\t\tlet
\t\t\tSource = AzureStorage.DataLake("", [HierarchicalNavigation=true])
\t\tin
\t\t\tSource
\tlineageTag: {uuid}

\tannotation PBI_IncludeFutureArtifacts = False
```
- The DataLake URL is empty string "" because the actual URL is resolved at runtime (Phase 7/8 will provide it). This is a template placeholder.
- lineageTag via `generate_deterministic_uuid("expression", catalog_name)`
- Validate with `validate_tmdl_indentation` before returning.

**`generate_column_tmdl(column: ColumnMetadata, table_qualified_name: str) -> str`:**
- Column header: `{indent(1)}column {quote_tmdl_identifier(column.name)}`
- dataType via `map_sql_type_to_tmdl(column.sql_type)`
- lineageTag via `generate_deterministic_uuid("column", f"{table_qualified_name}.{column.name}")`
- summarizeBy: none (per research recommendation)
- sourceColumn: column.name
- Annotation: `SummarizationSetBy = Automatic`
- All indented at level 2 (two tabs). Use `indent_tmdl(2)` for properties.
- Validate with `validate_tmdl_indentation` before returning.

**`generate_partition_tmdl(table: TableMetadata, partition_name: str, catalog_name: str) -> str`:**
- Partition header: `{indent(1)}partition {quote_tmdl_identifier(partition_name)} = entity`
- mode: directLake at indent level 2
- source block at indent level 2, properties at indent level 3:
  - entityName: table.table_name
  - schemaName: table.schema_name
  - expressionSource: 'DirectLake - {catalog_name}'
- Validate with `validate_tmdl_indentation` before returning.

**`generate_table_tmdl(table: TableMetadata, classification: TableClassification, key_prefixes: Sequence[str], catalog_name: str) -> str`:**
- Table header: `table {quote_tmdl_identifier(table.table_name)}`
- lineageTag via `generate_deterministic_uuid("table", f"{table.schema_name}.{table.table_name}")`
- Sort columns: key columns first (those starting with any key_prefix), then non-key columns alphabetically by name
- Generate each column via `generate_column_tmdl`
- Generate partition via `generate_partition_tmdl` with partition_name = table.table_name
- Compose all sections
- Validate with `validate_tmdl_indentation` before returning.

**Update `src/semantic_model_generator/tmdl/__init__.py`** to export all 6 functions.

Run `make check` - ALL tests should PASS (GREEN).
  </action>
  <verify>
`make check` passes. All new tests pass (GREEN). All 179 existing tests still pass. Total test count increased.
  </verify>
  <done>All 6 TMDL generation functions implemented and passing tests. All generated TMDL content passes whitespace validation. Column sorting (key first, then alphabetical) works correctly. Dimension-before-fact table sorting in model.tmdl works correctly.</done>
</task>

</tasks>

<verification>
1. `make check` passes (lint + typecheck + test)
2. All new tests pass covering database.tmdl, model.tmdl, expressions.tmdl, column, partition, and table generation
3. All existing 179 tests still pass
4. Generated TMDL uses tab indentation (validated by validate_tmdl_indentation)
5. `python -c "from semantic_model_generator.tmdl.generate import generate_database_tmdl, generate_table_tmdl"` succeeds
</verification>

<success_criteria>
- 6 TMDL generation functions exist and are tested
- database.tmdl output matches TMDL spec (compatibilityLevel: 1604)
- model.tmdl sorts dimensions before facts, within classification by (schema, table)
- expressions.tmdl uses en-US locale with DirectLake expression template
- Table TMDL includes columns with correct data types, deterministic UUIDs, and DirectLake partitions
- Column ordering: key columns first, then alphabetical
- All generated content passes whitespace validation (tabs only)
- Deterministic output: same inputs produce identical strings
</success_criteria>

<output>
After completion, create `.planning/phases/05-tmdl-generation/05-01-SUMMARY.md`
</output>
