# Phase 1: Project Foundation & Build System - Research

**Researched:** 2026-02-09
**Domain:** Python packaging, build tooling, quality automation
**Confidence:** HIGH

## Summary

Phase 1 establishes a modern Python package foundation with automated quality enforcement. The Python packaging ecosystem in 2026 strongly favors `pyproject.toml` with src layout for distributable packages. Build backends have matured: both setuptools (with setuptools-scm) and hatchling (with hatch-vcs) provide reliable dynamic versioning from git tags. Quality tools have consolidated: ruff has largely replaced multiple linting tools (flake8, isort, pyupgrade), mypy remains the standard for type checking, and pytest dominates testing. Pre-commit hooks are standard practice but require performance considerations.

For this greenfield project targeting PyPI distribution with TDD, the standard stack is: **pyproject.toml + src layout + hatchling + hatch-vcs + ruff + mypy strict + pytest + pre-commit + Makefile for CI-like local commands**.

The functional programming requirement (REQ-22) aligns well with Python's modern best practices: pure functions, dataclasses with frozen=True for immutability, and composition via higher-order functions. This is a well-supported style in the Python ecosystem.

**Primary recommendation:** Use hatchling + hatch-vcs for modern defaults and simpler configuration. Configure mypy strict mode from day 1 (easier than retrofitting). Keep pre-commit hooks fast (<1s total) by limiting to ruff formatting/linting only — run typecheck and tests in CI or manual `make check`.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| hatchling | latest | Build backend | PyPA-maintained, better defaults than setuptools, recommended by Python packaging guide 2026 |
| hatch-vcs | latest | Version management plugin | Official plugin for git-based versioning with hatchling |
| ruff | 0.15.0+ | Linter + formatter | 10-100x faster than alternatives, replaces flake8+isort+pyupgrade+black, 800+ rules, official Astral tooling |
| mypy | 1.19.1+ | Type checker | Industry standard for Python static typing, strict mode for maximum safety |
| pytest | latest | Testing framework | De facto standard for Python testing in 2026, replaced unittest for new projects |
| pre-commit | latest | Git hook manager | Standard for automated quality enforcement, isolated environments per hook |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| conventional-pre-commit | latest | Commit message validation | Enforces conventional commits format at commit-msg hook stage |
| pytest-cov | latest | Coverage reporting | Standard coverage plugin for pytest |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| hatchling | setuptools | setuptools has broader adoption but worse defaults (includes unintended files, requires MANIFEST.in). Use setuptools only if building C extensions. |
| hatch-vcs | setuptools-scm | setuptools-scm is more mature but tied to setuptools ecosystem. If using hatchling, hatch-vcs is the natural choice. |
| ruff | black + flake8 + isort | Traditional stack still works but requires 3+ tools where ruff provides one. Ruff is 10-100x faster. |
| pre-commit local hooks | git hooks directly | pre-commit provides isolation, version management, and language-agnostic approach. Manual hooks require custom bootstrapping. |

**Installation:**
Development tools installed separately (not in package dependencies):
```bash
pip install hatch-vcs ruff mypy pytest pytest-cov pre-commit
```

Build dependencies declared in pyproject.toml build-system.requires.

## Architecture Patterns

### Recommended Project Structure
```
semantic-model-generator/
├── .planning/                    # GSD phase documentation
├── src/
│   └── semantic_model_generator/
│       ├── __init__.py          # Empty or re-exports
│       ├── __main__.py          # Not needed (library, not CLI)
│       └── _version.py          # Generated by hatch-vcs
├── tests/
│   ├── __init__.py              # Optional
│   ├── conftest.py              # Shared fixtures
│   └── test_*.py                # Test modules
├── .pre-commit-config.yaml       # Hook configuration
├── pyproject.toml                # Single source of truth
├── Makefile                      # Developer convenience commands
└── README.md
```

**Rationale:**
- **src layout**: Prevents accidental imports from development directory, forces proper installation, catches packaging errors early
- **tests/ separate**: Clear boundary between source and tests, standard pytest discovery
- **No setup.py**: Deprecated pattern, pyproject.toml is PEP 517+ standard
- **No __main__.py**: Library for import in notebooks, not CLI tool
- **_version.py**: Generated at build time, not committed

### Pattern 1: pyproject.toml with Hatchling and Dynamic Versioning

**What:** Single configuration file for build system, project metadata, and all tool configurations

**When to use:** Always for modern Python packages (PEP 517+)

**Example:**
```toml
# Source: https://pypi.org/project/hatch-vcs/ + https://packaging.python.org/
[build-system]
requires = ["hatchling", "hatch-vcs"]
build-backend = "hatchling.build"

[project]
name = "semantic-model-generator"
dynamic = ["version"]
description = "Generate TMDL semantic models from Fabric warehouse metadata"
readme = "README.md"
requires-python = ">=3.11"
license = {text = "MIT"}
authors = [
    {name = "Your Name", email = "you@example.com"},
]
classifiers = [
    "Development Status :: 3 - Alpha",
    "Intended Audience :: Developers",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
]
dependencies = []  # Runtime dependencies

[project.urls]
Homepage = "https://github.com/yourusername/semantic-model-generator"
Repository = "https://github.com/yourusername/semantic-model-generator"

[tool.hatch.version]
source = "vcs"

[tool.hatch.build.hooks.vcs]
version-file = "src/semantic_model_generator/_version.py"

[tool.hatch.build.targets.sdist]
include = [
    "/src",
    "/tests",
]

[tool.hatch.build.targets.wheel]
packages = ["src/semantic_model_generator"]
```

### Pattern 2: Mypy Strict Mode Configuration

**What:** Enable all optional type checking flags from day 1

**When to use:** New projects starting with type hints (easier than retrofitting)

**Example:**
```toml
# Source: https://mypy.readthedocs.io/en/stable/config_file.html
[tool.mypy]
python_version = "3.11"
strict = true
warn_unused_configs = true

# Per-module overrides for third-party libraries without type stubs
[[tool.mypy.overrides]]
module = "notebookutils.*"
ignore_missing_imports = true

[[tool.mypy.overrides]]
module = "mssql.*"
ignore_missing_imports = true
```

**Strict mode enables:**
- `--disallow-untyped-defs`: All functions must have type hints
- `--disallow-any-generics`: Generics must be parameterized
- `--warn-return-any`: Flag functions that return Any
- `--no-implicit-reexport`: Explicit re-exports only
- `--strict-equality`: Prevent comparisons between incompatible types
- Plus 10+ more safety checks

### Pattern 3: Ruff Configuration

**What:** Fast linter + formatter with sensible defaults

**When to use:** All Python projects (replaces multiple tools)

**Example:**
```toml
# Source: https://docs.astral.sh/ruff/configuration/
[tool.ruff]
line-length = 100
target-version = "py311"

[tool.ruff.lint]
select = [
    "E",   # pycodestyle errors
    "W",   # pycodestyle warnings
    "F",   # pyflakes
    "I",   # isort
    "B",   # flake8-bugbear
    "C4",  # flake8-comprehensions
    "UP",  # pyupgrade
]
ignore = []

[tool.ruff.lint.per-file-ignores]
"tests/**/*.py" = [
    "S101",  # Allow assert in tests
]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
```

### Pattern 4: Pytest Configuration

**What:** Test framework configuration for src layout with importlib mode

**When to use:** Always with src layout (prevents import path issues)

**Example:**
```toml
# Source: https://docs.pytest.org/en/stable/explanation/goodpractices.html
[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
addopts = [
    "--import-mode=importlib",
    "--strict-markers",
    "-ra",
]

[tool.coverage.run]
source = ["semantic_model_generator"]
omit = ["*/tests/*", "*/_version.py"]

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "raise AssertionError",
    "raise NotImplementedError",
    "if __name__ == .__main__.:",
]
```

### Pattern 5: Pre-commit Hook Configuration

**What:** Automated quality checks on commit with isolated environments

**When to use:** Always (standard practice in 2026)

**Example:**
```yaml
# Source: https://pre-commit.com/ + https://github.com/compilerla/conventional-pre-commit
default_language_version:
  python: python3.11

default_install_hook_types:
  - pre-commit
  - commit-msg

repos:
  # Basic pre-commit hooks
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v6.0.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files
      - id: check-merge-conflict

  # Ruff linting and formatting
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.15.0
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format

  # Commit message validation
  - repo: https://github.com/compilerla/conventional-pre-commit
    rev: v3.6.0
    hooks:
      - id: conventional-pre-commit
        stages: [commit-msg]
```

**Performance note:** Do NOT include mypy or pytest in pre-commit hooks — they're too slow (>1s). Run them via `make check` or CI instead.

### Pattern 6: Makefile for Development Commands

**What:** Simple automation for lint, typecheck, test, and check targets

**When to use:** Always (standard convenience layer)

**Example:**
```makefile
# Source: Common Python project pattern
.PHONY: help install lint typecheck test check clean

help:
	@echo "Available targets:"
	@echo "  install    - Install package in editable mode with dev dependencies"
	@echo "  lint       - Run ruff linter"
	@echo "  typecheck  - Run mypy type checker"
	@echo "  test       - Run pytest"
	@echo "  check      - Run lint + typecheck + test (pre-push validation)"
	@echo "  clean      - Remove build artifacts"

install:
	pip install -e .
	pip install ruff mypy pytest pytest-cov pre-commit
	pre-commit install --install-hooks

lint:
	ruff check src tests

typecheck:
	mypy src

test:
	pytest

check: lint typecheck test

clean:
	rm -rf build dist src/*.egg-info .pytest_cache .mypy_cache .ruff_cache
	find . -type d -name __pycache__ -exec rm -rf {} +
```

### Pattern 7: Functional Programming Style

**What:** Pure functions, immutable data structures, composition

**When to use:** Per REQ-22 — throughout the codebase

**Example:**
```python
# Source: https://docs.python.org/3/howto/functional.html
from dataclasses import dataclass
from typing import Callable

# Immutable data structures
@dataclass(frozen=True)
class TableMetadata:
    schema: str
    name: str
    columns: tuple[str, ...]  # Immutable tuple, not mutable list

# Pure functions (no side effects, deterministic)
def classify_table(metadata: TableMetadata, key_prefix: str) -> str:
    """Classify table as dimension or fact based on key count."""
    key_count = sum(1 for col in metadata.columns if col.startswith(key_prefix))
    return "dimension" if key_count == 1 else "fact"

# Higher-order functions for composition
def filter_tables(
    tables: list[TableMetadata],
    predicate: Callable[[TableMetadata], bool]
) -> list[TableMetadata]:
    """Filter tables using provided predicate function."""
    return [t for t in tables if predicate(t)]

# Composition via function pipelines
def process_tables(
    tables: list[TableMetadata],
    key_prefix: str
) -> dict[str, list[TableMetadata]]:
    """Process tables through functional pipeline."""
    # Each step is a pure function
    filtered = filter_tables(tables, lambda t: not t.name.startswith("tmp_"))
    classified = {
        "dimensions": [t for t in filtered if classify_table(t, key_prefix) == "dimension"],
        "facts": [t for t in filtered if classify_table(t, key_prefix) == "fact"],
    }
    return classified
```

**Key principles:**
- Use `@dataclass(frozen=True)` for immutable data
- Prefer tuples over lists when data shouldn't change
- Avoid classes unless grouping related functions logically
- Use `functools` module (partial, reduce, etc.)
- Use `itertools` for lazy iteration
- Avoid mutation and side effects in business logic

### Anti-Patterns to Avoid

- **Flat layout for distributable packages:** Causes import path confusion and accidental imports from development directory. Always use src layout for PyPI packages.
- **Hardcoded version strings:** Use dynamic versioning (hatch-vcs or setuptools-scm) for automatic git tag-based versions.
- **Skipping setuptools 80+:** Older setuptools versions have bugs with pyproject.toml. Require setuptools >=80 if using setuptools backend.
- **Missing [build-system] table:** PEP 517 requires build-system table even with setuptools. Always include it.
- **Invalid PyPI classifiers:** Classifier strings must match PyPI's exact list (case-sensitive). Check https://pypi.org/classifiers/ before publishing.
- **Case-insensitive README references:** `readme = "rEaDmE.mD"` works on macOS/Windows but fails on Linux. Use exact case.
- **Running tests without installation (src layout):** Src layout requires `pip install -e .` for tests to import package. Don't rely on PYTHONPATH hacks.
- **Heavy pre-commit hooks:** Hooks >1s kill developer velocity. Keep pre-commit to fast checks only (ruff, yaml validation). Run mypy/pytest in CI or manual `make check`.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Version management | Manual version bumping, __version__ strings | hatch-vcs or setuptools-scm | Git tags are source of truth. Manual versions drift, require coordination, cause merge conflicts. |
| Code formatting | Custom style checker, manual formatting | ruff format | Formatting is solved. Ruff is 100x faster than black and enforces consistent style automatically. |
| Linting | Custom lint rules, shell script linters | ruff check | 800+ battle-tested rules, auto-fix capability, handles imports/upgrades/bug patterns. |
| Import sorting | Manual sorting, custom import grouping | ruff (replaces isort) | Import organization is complex (stdlib vs third-party vs local). Ruff handles all edge cases. |
| Git hooks | Bash scripts in .git/hooks/ | pre-commit framework | Hook bootstrapping, language-specific environments, version pinning, sharing configs across projects. |
| Build system | setup.py with manual build logic | hatchling or setuptools with pyproject.toml | PEP 517+ standard, reproducible builds, lockfile support, modern tooling compatibility. |
| Test discovery | Custom test runners, manual test collection | pytest | Fixture system, parametrization, plugins, parallel execution, coverage integration. |
| Commit message validation | Regex in bash script | conventional-pre-commit | Handles all Conventional Commits edge cases (scope, body, footer, breaking changes). |

**Key insight:** The Python packaging and quality tooling ecosystem matured significantly by 2026. The problems in this domain have well-tested, actively-maintained solutions. Custom implementations introduce maintenance burden and miss edge cases that standard tools handle.

## Common Pitfalls

### Pitfall 1: Editable Install Not Performed

**What goes wrong:** With src layout, running `pytest` or importing package fails with "ModuleNotFoundError" even though code exists.

**Why it happens:** src layout intentionally excludes source code from Python's import path. This forces proper installation and prevents tests from accidentally using development files instead of installed package.

**How to avoid:**
1. Always run `pip install -e .` after cloning
2. Document in README: "Run `make install` or `pip install -e .` before testing"
3. Add `.python-version` or document Python version requirement

**Warning signs:**
- Tests work for you but fail for others on fresh clone
- ImportError in pytest but files exist in src/
- `python -c "import semantic_model_generator"` fails

### Pitfall 2: Mypy Strict Mode with Untyped Third-Party Libraries

**What goes wrong:** mypy strict mode fails on imports like `import notebookutils` even though runtime works fine.

**Why it happens:** Strict mode's `--disallow-any-generics` and related flags require type information for all imports. Many Python libraries (especially Fabric-specific ones like notebookutils) don't ship type stubs.

**How to avoid:**
1. Use per-module overrides with `ignore_missing_imports = true`
2. Start with strict = true but add overrides incrementally as you discover untyped dependencies
3. Check if type stubs exist on PyPI (e.g., `types-requests`) before using ignore_missing_imports

**Warning signs:**
- `error: Skipping analyzing "notebookutils": module is installed, but missing library stubs or py.typed marker`
- `error: Library stubs not installed for "mssql"`

**Example fix:**
```toml
[[tool.mypy.overrides]]
module = ["notebookutils.*", "mssql.*"]
ignore_missing_imports = true
```

### Pitfall 3: Slow Pre-commit Hooks

**What goes wrong:** Every commit takes 15-30 seconds. Developers start using `git commit --no-verify` to bypass hooks.

**Why it happens:** Running full test suite or type checking entire codebase on every commit. Pre-commit creates isolated environments which adds overhead.

**How to avoid:**
1. Keep pre-commit to <1s fast checks: ruff, trailing whitespace, YAML validation
2. Run mypy and pytest in `make check` target (manual) or CI (automated)
3. Use `pre-commit run --all-files` only in CI, not on every commit
4. Consider using `ruff` instead of multiple slower tools

**Warning signs:**
- Commits take >5 seconds
- Developers complain about "waiting for hooks"
- `--no-verify` usage in git logs

### Pitfall 4: Missing Python Version Specification

**What goes wrong:** Build fails in CI or for users with Python 3.9 because code uses 3.11+ features (e.g., `X | None` syntax, match statements).

**Why it happens:** `requires-python` in pyproject.toml not set or set too low.

**How to avoid:**
1. Set `requires-python = ">=3.11"` in pyproject.toml
2. Set `target-version = "py311"` in ruff config
3. Set `python_version = "3.11"` in mypy config
4. Use `.python-version` file for local development consistency

**Warning signs:**
- CI failures on older Python versions
- `SyntaxError: invalid syntax` on union types or match statements
- Users report "doesn't work on Python 3.10"

### Pitfall 5: Dynamic Version Not Generated

**What goes wrong:** `pip install -e .` succeeds but `import semantic_model_generator; print(semantic_model_generator.__version__)` raises `AttributeError`.

**Why it happens:** hatch-vcs only generates `_version.py` during build (`pip install`), not in development mode. Or no git tags exist yet.

**How to avoid:**
1. Create initial git tag: `git tag v0.0.1`
2. Access version via `importlib.metadata.version("semantic-model-generator")` not `__version__` attribute
3. If you need `__version__` attribute, add `version-file` in hatch config and re-install after tagging

**Warning signs:**
- `AttributeError: module 'semantic_model_generator' has no attribute '__version__'`
- Version shows "0.0.0" or "unknown"
- hatch-vcs warnings about "no version found"

### Pitfall 6: Test File Naming Mismatch

**What goes wrong:** pytest doesn't discover your tests. `pytest` reports "collected 0 items".

**Why it happens:** pytest looks for `test_*.py` or `*_test.py` by default. Files named `tests.py` or `unit_tests.py` aren't discovered.

**How to avoid:**
1. Name test files `test_*.py` (e.g., `test_classification.py`)
2. Name test functions `test_*` (e.g., `def test_dimension_classification():`)
3. Place tests in `tests/` directory
4. Run `pytest --collect-only` to see what pytest discovers

**Warning signs:**
- `pytest` exits immediately with 0 tests
- Tests exist but aren't run
- Coverage report shows 0% coverage

### Pitfall 7: Ruff Per-File Ignores Not Working

**What goes wrong:** ruff still reports errors in test files even though you configured per-file ignores.

**Why it happens:** Glob pattern doesn't match or rule code is wrong.

**How to avoid:**
1. Use `tests/**/*.py` pattern (not `tests/*.py` if you have subdirectories)
2. Verify rule codes match ruff's output (e.g., `S101` not `assert-in-tests`)
3. Run `ruff check --show-settings` to see effective configuration

**Warning signs:**
- Test files still flagged for rules you thought were ignored
- `S101` (assert) errors in test files

**Example fix:**
```toml
[tool.ruff.lint.per-file-ignores]
"tests/**/*.py" = ["S101", "D"]  # Allow assert, no docstrings in tests
"**/conftest.py" = ["D"]  # No docstrings required in conftest
```

### Pitfall 8: Conftest.py Not Discovered

**What goes wrong:** Fixtures defined in `conftest.py` aren't available to tests. pytest reports "fixture 'my_fixture' not found".

**Why it happens:** conftest.py in wrong location, named incorrectly (e.g., `conf.py`), or missing `__init__.py` in tests directory for older pytest versions.

**How to avoid:**
1. Place `conftest.py` in `tests/` directory (discovered for all tests in that dir and subdirs)
2. Name it exactly `conftest.py` (not `conf.py` or `test_conftest.py`)
3. Fixtures are automatically discovered, no imports needed in test files

**Warning signs:**
- `fixture 'my_fixture' not found`
- Tests work when fixtures defined locally but not when moved to conftest

### Pitfall 9: Build-System Requires vs Project Dependencies

**What goes wrong:** Package installs but `hatch-vcs` isn't found during build. Or runtime imports fail for build dependencies.

**Why it happens:** Confusion between `build-system.requires` (needed to build package) and `project.dependencies` (needed to run package).

**How to avoid:**
1. `build-system.requires`: hatchling, hatch-vcs (build time only)
2. `project.dependencies`: requests, pandas, etc. (runtime dependencies)
3. Dev tools (ruff, mypy, pytest) go in neither — installed separately via `pip install` or requirements-dev.txt

**Warning signs:**
- Build fails with "ModuleNotFoundError: hatch_vcs"
- Runtime fails with "ModuleNotFoundError: hatchling"

**Correct separation:**
```toml
[build-system]
requires = ["hatchling", "hatch-vcs"]  # Build time only

[project]
dependencies = ["requests>=2.31"]  # Runtime only

# Dev tools installed separately: pip install ruff mypy pytest
```

### Pitfall 10: Conventional Commit Validation Too Strict

**What goes wrong:** Valid-looking commit messages rejected by conventional-pre-commit. Team frustration.

**Why it happens:** Default strict mode requires specific types, forbids certain patterns. Team's existing commit style doesn't match.

**How to avoid:**
1. Start without `--strict` flag to allow more flexibility
2. Configure allowed types: `args: ["--strict", "--types", "feat,fix,docs,chore,test,refactor"]`
3. Document commit format in CONTRIBUTING.md
4. Provide examples in pre-commit hook error messages

**Warning signs:**
- Frequent commit hook failures
- Developers asking "why was this rejected?"
- `git commit --no-verify` usage

## Code Examples

Verified patterns from official sources:

### Complete pyproject.toml for Greenfield Project

```toml
# Consolidated example based on official documentation
[build-system]
requires = ["hatchling", "hatch-vcs"]
build-backend = "hatchling.build"

[project]
name = "semantic-model-generator"
dynamic = ["version"]
description = "Generate TMDL semantic models from Fabric warehouse metadata"
readme = "README.md"
requires-python = ">=3.11"
license = {text = "MIT"}
authors = [
    {name = "Your Name", email = "you@example.com"},
]
classifiers = [
    "Development Status :: 3 - Alpha",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
]
dependencies = []

[project.urls]
Homepage = "https://github.com/yourusername/semantic-model-generator"
Repository = "https://github.com/yourusername/semantic-model-generator"
Issues = "https://github.com/yourusername/semantic-model-generator/issues"

# Hatchling + hatch-vcs configuration
[tool.hatch.version]
source = "vcs"

[tool.hatch.build.hooks.vcs]
version-file = "src/semantic_model_generator/_version.py"

[tool.hatch.build.targets.sdist]
include = ["/src", "/tests", "/README.md", "/LICENSE"]

[tool.hatch.build.targets.wheel]
packages = ["src/semantic_model_generator"]

# Ruff configuration
[tool.ruff]
line-length = 100
target-version = "py311"

[tool.ruff.lint]
select = ["E", "W", "F", "I", "B", "C4", "UP"]
ignore = []

[tool.ruff.lint.per-file-ignores]
"tests/**/*.py" = ["S101"]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"

# Mypy configuration
[tool.mypy]
python_version = "3.11"
strict = true
warn_unused_configs = true

[[tool.mypy.overrides]]
module = ["notebookutils.*", "mssql.*"]
ignore_missing_imports = true

# Pytest configuration
[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
addopts = ["--import-mode=importlib", "--strict-markers", "-ra"]

[tool.coverage.run]
source = ["semantic_model_generator"]
omit = ["*/tests/*", "*/_version.py"]

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "raise AssertionError",
    "raise NotImplementedError",
    "if __name__ == .__main__.:",
]
```

### First Test (TDD Starter)

```python
# tests/test_placeholder.py
"""Placeholder test to ensure pytest runs successfully."""


def test_placeholder():
    """Verify pytest is working."""
    assert True, "If this fails, pytest itself is broken"
```

### Pre-commit Config for Fast Hooks

```yaml
# .pre-commit-config.yaml
default_language_version:
  python: python3.11

default_install_hook_types:
  - pre-commit
  - commit-msg

repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v6.0.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files
      - id: check-merge-conflict

  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.15.0
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format

  - repo: https://github.com/compilerla/conventional-pre-commit
    rev: v3.6.0
    hooks:
      - id: conventional-pre-commit
        stages: [commit-msg]
```

### Makefile with Check Target

```makefile
.PHONY: help install lint typecheck test check clean

help:
	@echo "Available targets:"
	@echo "  install    - Install package in editable mode with dev dependencies"
	@echo "  lint       - Run ruff linter"
	@echo "  typecheck  - Run mypy type checker"
	@echo "  test       - Run pytest"
	@echo "  check      - Run lint + typecheck + test (CI-equivalent)"
	@echo "  clean      - Remove build artifacts"

install:
	pip install -e .
	pip install ruff mypy pytest pytest-cov pre-commit
	pre-commit install --install-hooks

lint:
	ruff check src tests

typecheck:
	mypy src

test:
	pytest

check: lint typecheck test
	@echo "All checks passed!"

clean:
	rm -rf build dist src/*.egg-info .pytest_cache .mypy_cache .ruff_cache
	find . -type d -name __pycache__ -exec rm -rf {} +
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| setup.py + setup.cfg | pyproject.toml | PEP 517 (2017), standard by 2022 | Single config file, PEP 621 metadata, modern tool compatibility |
| black + flake8 + isort + pyupgrade | ruff | 2023-2024 | 10-100x faster, one tool replaces four, consistent formatting+linting |
| unittest | pytest | Gradual since ~2015, dominant by 2020 | Simpler syntax, fixtures, parametrization, rich plugin ecosystem |
| Manual version bumping | setuptools-scm / hatch-vcs | setuptools-scm since 2016, hatch-vcs 2022+ | Git tags as source of truth, eliminates version drift and merge conflicts |
| Flat layout | src layout | Recommended since ~2018, strongly advocated by 2023 | Prevents import path confusion, catches packaging errors early |
| Bash git hooks | pre-commit framework | Mainstream by 2020 | Isolated environments, version management, language-agnostic |

**Deprecated/outdated:**
- **setup.py with distutils**: Removed in Python 3.12. Use pyproject.toml + PEP 517 backend.
- **setuptools test command**: Deprecated and removed. Use pytest directly.
- **--editable-mode=compat for pytest**: Deprecated. Use `--import-mode=importlib` with src layout.
- **nose/nose2 test framework**: Unmaintained. Migrate to pytest.
- **Manual MANIFEST.in with hatchling**: Hatchling uses better defaults from .gitignore. Only needed for edge cases.

## Open Questions

1. **Exact Python version target in Fabric**
   - What we know: Fabric notebooks run PySpark with Python 3.11+ as of 2026
   - What's unclear: Exact minor version (3.11.x vs 3.12.x)
   - Recommendation: Start with `requires-python = ">=3.11"` and adjust if Fabric version is pinned

2. **notebookutils type stubs**
   - What we know: notebookutils is Fabric-specific, likely no PyPI type stubs
   - What's unclear: Whether Microsoft ships .pyi files or py.typed marker
   - Recommendation: Use mypy override with `ignore_missing_imports = true` initially, investigate type stubs in Phase 2

3. **CI/CD platform**
   - What we know: Need automated testing and PyPI publishing
   - What's unclear: GitHub Actions vs Azure DevOps vs other
   - Recommendation: Assume GitHub Actions (most common for open source), document in Phase 8 planning

4. **License choice**
   - What we know: PyPI package requires license
   - What's unclear: MIT vs Apache 2.0 vs other
   - Recommendation: Ask user or default to MIT (most permissive, common for Python libraries)

5. **Functional programming vs dataclasses (technically classes)**
   - What we know: REQ-22 says "no classes unless strictly necessary"
   - What's unclear: Are frozen dataclasses acceptable? (They're immutable, functional-friendly)
   - Recommendation: Use `@dataclass(frozen=True)` as acceptable — they're essentially named tuples with better syntax. Check with user if concerned.

## Sources

### Primary (HIGH confidence)
- [Python Packaging User Guide - src layout vs flat layout](https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/) - src layout recommendations
- [Python Packaging User Guide - Writing pyproject.toml](https://packaging.python.org/en/latest/guides/writing-pyproject-toml/) - pyproject.toml structure
- [setuptools-scm Usage Documentation](https://setuptools-scm.readthedocs.io/en/latest/usage/) - dynamic versioning setup
- [Ruff Official Documentation](https://docs.astral.sh/ruff/) - linter/formatter configuration
- [Mypy Configuration File Documentation](https://mypy.readthedocs.io/en/stable/config_file.html) - strict mode and config
- [pytest Good Integration Practices](https://docs.pytest.org/en/stable/explanation/goodpractices.html) - test structure with src layout
- [pre-commit Official Documentation](https://pre-commit.com/) - hook framework setup
- [hatch-vcs PyPI Page](https://pypi.org/project/hatch-vcs/) - hatchling version plugin

### Secondary (MEDIUM confidence)
- [Hatchling vs Setuptools Blog Post](https://www.oreateai.com/blog/hatchling-vs-setuptools-the-future-of-python-packaging/500f5340e750b19c738ab8e69a86bcaa) - build backend comparison (2026)
- [Python Build Backends 2025 Article](https://medium.com/@dynamicy/python-build-backends-in-2025-what-to-use-and-why-uv-build-vs-hatchling-vs-poetry-core-94dd6b92248f) - current state analysis
- [conventional-pre-commit GitHub](https://github.com/compilerla/conventional-pre-commit) - commit message validation
- [Ruff Configuration Guide](https://betterstack.com/community/guides/scaling-python/ruff-explained/) - practical ruff setup
- [Modern TDD with pytest](https://testdriven.io/blog/modern-tdd/) - TDD workflow patterns
- [Python Functional Programming HOWTO](https://docs.python.org/3/howto/functional.html) - official functional programming guide
- [Real Python - Functional Programming in Python](https://realpython.com/python-functional-programming/) - functional patterns and best practices

### Tertiary (LOW confidence - flagged for validation)
- Various blog posts on Makefile patterns - no single authoritative source, synthesized from multiple examples
- Performance claims about pre-commit slowness - community discussions, not official benchmarks
- Specific version numbers for tools in 2026 - may be outdated rapidly, verify during implementation

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All tools are official, well-documented, with PyPA or major community backing
- Architecture: HIGH - src layout and pyproject.toml are PEP-standardized, pytest patterns from official docs
- Pitfalls: MEDIUM-HIGH - Based on official docs + community experience, but some edge cases may be project-specific
- Functional programming: MEDIUM - Python supports functional style but isn't purely functional, patterns are established but not as standardized as in FP-first languages
- Build backend choice (hatchling vs setuptools): MEDIUM - Both are valid, recommendation based on current trends and defaults, but setuptools still more widely adopted

**Research date:** 2026-02-09
**Valid until:** ~2026-03-09 (30 days - packaging ecosystem is stable, but tool versions update monthly)

**Recommendation for validation:**
- Verify ruff and mypy versions when implementing (use latest stable)
- Confirm Python 3.11+ is correct for Fabric environment
- Check if newer hatchling or hatch-vcs versions released
- Validate pre-commit hook repository versions (v6.0.0, v0.15.0, v3.6.0 cited here)
