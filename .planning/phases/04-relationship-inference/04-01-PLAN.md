---
phase: 04-relationship-inference
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/semantic_model_generator/domain/types.py
  - src/semantic_model_generator/schema/relationships.py
  - src/semantic_model_generator/schema/__init__.py
  - tests/schema/test_relationships.py
autonomous: true

must_haves:
  truths:
    - "Fact tables with key columns matching dimension key columns produce many-to-one relationships"
    - "When a fact references the same dimension multiple times via different key columns, the first relationship (by sorted column name) is active and subsequent ones are inactive"
    - "Columns whose name exactly matches a key prefix produce no relationships (empty base name cannot match dimensions) and are excluded from role-playing grouping"
    - "Relationship inference is deterministic -- same inputs always produce same output order and UUIDs"
  artifacts:
    - path: "src/semantic_model_generator/domain/types.py"
      provides: "Relationship frozen dataclass"
      contains: "class Relationship"
    - path: "src/semantic_model_generator/schema/relationships.py"
      provides: "Relationship inference functions"
      exports: ["infer_relationships", "strip_prefix", "is_exact_match"]
    - path: "tests/schema/test_relationships.py"
      provides: "Comprehensive TDD tests"
      min_lines: 100
  key_links:
    - from: "src/semantic_model_generator/schema/relationships.py"
      to: "src/semantic_model_generator/domain/types.py"
      via: "imports Relationship, TableMetadata, TableClassification, ColumnMetadata"
      pattern: "from semantic_model_generator\\.domain\\.types import"
    - from: "src/semantic_model_generator/schema/relationships.py"
      to: "src/semantic_model_generator/utils/uuid_gen.py"
      via: "imports generate_deterministic_uuid for relationship IDs"
      pattern: "from semantic_model_generator\\.utils\\.uuid_gen import"
    - from: "src/semantic_model_generator/schema/relationships.py"
      to: "src/semantic_model_generator/schema/classification.py"
      via: "uses classify_tables output (dict of (schema,table)->classification)"
      pattern: "TableClassification"
---

<objective>
Implement relationship inference between fact and dimension tables using TDD.

Given classified table metadata and user-supplied key prefixes, infer star-schema relationships (fact many-to-one dimension) by matching key column base names after prefix stripping. Detect role-playing dimensions (same dimension referenced multiple times from one fact), mark the first relationship active and subsequent ones inactive, and handle exact-match prefixes that bypass role-playing detection.

Purpose: REQ-06, REQ-07, REQ-08, REQ-09 -- relationship inference is the bridge between schema discovery (Phase 3) and TMDL generation (Phase 5). Without correct relationships, the semantic model cannot express star-schema joins.

Output: `Relationship` dataclass, `infer_relationships()` function, comprehensive tests, all passing `make check`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/semantic_model_generator/domain/types.py
@src/semantic_model_generator/schema/classification.py
@src/semantic_model_generator/schema/filtering.py
@src/semantic_model_generator/schema/__init__.py
@src/semantic_model_generator/utils/uuid_gen.py
@tests/schema/test_classification.py

@.planning/phases/04-relationship-inference/04-RESEARCH.md
@.references/Semantic Model Generator.ipynb
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Write failing tests for Relationship dataclass and relationship inference</name>
  <files>
    tests/schema/test_relationships.py
    src/semantic_model_generator/domain/types.py
  </files>
  <action>
Create `tests/schema/test_relationships.py` with comprehensive tests covering all four requirements. Use the existing test helper pattern from `test_classification.py` (the `make_column` helper).

**Part A: Relationship dataclass tests** (in test file, but Relationship added to types.py as minimal stub to make imports work)

Add a `Relationship` frozen dataclass to `src/semantic_model_generator/domain/types.py`:
```python
@dataclass(frozen=True, slots=True)
class Relationship:
    """Inferred star-schema relationship between tables."""
    id: uuid.UUID
    from_table: str      # Schema-qualified fact table: "dbo.FactSales"
    from_column: str     # FK column name: "FK_CustomerID"
    to_table: str        # Schema-qualified dim table: "dbo.DimCustomer"
    to_column: str       # PK column name: "SK_CustomerID"
    is_active: bool
    cross_filtering_behavior: str = "oneDirection"
    from_cardinality: str = "many"
    to_cardinality: str = "one"
```

Import `uuid` at the top of types.py. This dataclass is needed so tests can import it.

Tests for Relationship dataclass:
- Is frozen (cannot assign attributes after creation)
- Has correct default values (cross_filtering_behavior, cardinalities)
- Fields are accessible

**Part B: Helper functions -- strip_prefix and is_exact_match**

Create stub functions in a new `src/semantic_model_generator/schema/relationships.py` that raise `NotImplementedError` so tests can import but fail:

```python
def strip_prefix(column_name: str, key_prefixes: Sequence[str]) -> str | None:
    raise NotImplementedError

def is_exact_match(column_name: str, key_prefixes: Sequence[str]) -> bool:
    raise NotImplementedError

def infer_relationships(
    tables: Sequence[TableMetadata],
    classifications: dict[tuple[str, str], TableClassification],
    key_prefixes: Sequence[str],
) -> tuple[Relationship, ...]:
    raise NotImplementedError
```

Tests for `strip_prefix`:
- `strip_prefix("FK_CustomerID", ["SK_", "FK_"])` returns `"CustomerID"`
- `strip_prefix("SK_ProductID", ["SK_", "FK_"])` returns `"ProductID"`
- `strip_prefix("Name", ["SK_", "FK_"])` returns `None` (no prefix match)
- `strip_prefix("FK_", ["FK_"])` returns `""` (empty string after stripping -- exact match case)
- First matching prefix wins: `strip_prefix("SK_FK_Data", ["SK_", "FK_"])` returns `"FK_Data"`

Tests for `is_exact_match`:
- `is_exact_match("SK_", ["SK_", "FK_"])` returns `True`
- `is_exact_match("SK_CustomerID", ["SK_", "FK_"])` returns `False`
- `is_exact_match("Name", ["SK_", "FK_"])` returns `False`
- `is_exact_match("FK_", ["FK_"])` returns `True`

**Part C: infer_relationships tests**

Build test data using `TableMetadata` and `ColumnMetadata` from domain types, and classification dicts.

REQ-06 -- Basic relationship inference:
- `test_infer_single_fact_to_single_dimension`: One fact with `FK_CustomerID`, one dim with `SK_CustomerID`, prefixes `["SK_", "FK_"]`. Expect 1 relationship: fact->dim, is_active=True, from_cardinality="many", to_cardinality="one".
- `test_infer_fact_to_multiple_dimensions`: Fact with `FK_CustomerID` and `FK_ProductID`, two dims with matching keys. Expect 2 relationships, both active.
- `test_no_relationship_when_no_key_match`: Fact has `FK_OrderID` but no dim has a key stripping to `OrderID`. Expect 0 relationships.
- `test_unclassified_tables_ignored`: Tables classified as UNCLASSIFIED are not involved in relationships.
- `test_dimension_to_dimension_no_relationship`: Two dimensions should not create relationships between each other.
- `test_empty_tables_returns_empty`: Empty input returns empty tuple.

REQ-07 -- Role-playing dimensions:
- `test_role_playing_dimension_detected`: Fact has `FK_BillToCustomerID` and `FK_ShipToCustomerID`. Dim has `SK_CustomerID`. After prefix stripping, fact columns become `BillToCustomerID` and `ShipToCustomerID` -- these do NOT match `CustomerID`. This means role-playing requires a DIFFERENT matching strategy.

**IMPORTANT CLARIFICATION from the reference notebook:** The reference notebook uses a different approach. It strips the prefix to get a "base key" using double-underscore segmentation: `_hk__customer__bill_to` strips to base key `_hk__customer`, which matches dimension's `_hk__customer`. Our project uses simpler prefixes like `SK_`, `FK_`, `ID_`. The matching strategy must be:

For each fact key column, strip the prefix. For each dimension, get its single key column and strip its prefix. If the **fact column base name ends with the dimension column base name** OR the **fact column base name equals the dimension column base name**, it's a match. Wait -- this doesn't work either.

Re-reading the reference notebook more carefully: it uses `extract_base_key` which takes `_hk__customer__bill_to` and returns `_hk__customer` (prefix + first segment before `__`). Then matches base keys.

For our simpler prefix scheme (like `ID_`), the reference notebook's actual usage is with prefix `ID_`. Looking at the notebook execution: 45 tables, 72 relationships, prefix `ID_`. So columns are like `ID_Customer`, `ID_Product`, etc. in both facts and dimensions. A fact has `ID_Customer` matching dim's `ID_Customer` exactly.

So the matching logic is simpler than the research suggested: **after stripping the prefix, the base names must be equal**. Role-playing happens when the column names differ but still reference the same dimension -- e.g., a fact has `ID_Customer_BillTo` and `ID_Customer_SellTo`, while the dim has `ID_Customer`. But with simple prefix stripping, these would become `Customer_BillTo` vs `Customer`, which do NOT match.

The reference notebook solves this with the `extract_base_key` function that takes the first segment: `_hk__customer__bill_to` -> base key `_hk__customer`. For our prefix `ID_`, we need a similar concept: `ID_Customer_BillTo` -> base key `Customer` (strip prefix, take first segment before some separator).

However, looking at the research more carefully: the research says "match fact FK columns to dimension PK columns by stripping prefixes and comparing base names." And for role-playing: "same dimension is referenced multiple times from a single fact with different key column prefixes." This suggests the base name comparison IS the matching mechanism, and role-playing is detected AFTER matching by grouping by (from_table, to_table).

The simplest correct interpretation: a fact column `FK_CustomerID` matches a dimension column `SK_CustomerID` because both strip to `CustomerID`. Role-playing means a fact has TWO columns that both match the SAME dimension: e.g., `FK_CustomerID` and `FK_CustomerID_BillTo` where somehow both match. But with simple equality, `CustomerID` != `CustomerID_BillTo`.

**Resolution:** Follow the reference notebook's pattern. The matching needs a "base key extraction" similar to the notebook's `extract_base_key`. For the general case:
1. Strip the key prefix from the column name
2. Compare the stripped base names -- if equal, it's a match
3. Role-playing is when MULTIPLE fact columns match the SAME dimension (because they all have the same base name after stripping)

In practice with `ID_` prefix: fact has `ID_Customer` and dim has `ID_Customer` -- direct match. If a fact has `ID_Customer` appearing twice (impossible, column names are unique), there's no role-playing. Role-playing requires the reference notebook's double-underscore segmentation pattern.

**Final design:** Support BOTH matching modes:
- **Exact base match:** `strip_prefix(fact_col) == strip_prefix(dim_col)` -- the standard match
- **Role-playing via base key extraction:** If column has double-underscore segments after prefix stripping, extract just the first segment as the base key for matching. E.g., `FK_Customer__BillTo` -> base key `Customer` matches dim's `SK_Customer` -> base key `Customer`.

Actually, let me simplify. The research and requirements say: "key columns across tables" for matching. The reference notebook has a specific `extract_base_key` for its `__` convention. Let me NOT over-engineer this and instead:

1. Match by equal base names after prefix stripping (simple case)
2. Role-playing is detected as a POST-PROCESSING step: group all relationships by (from_table, to_table), and if there are multiple, first is active, rest inactive
3. For role-playing to work, we need multiple fact columns to match the same dimension -- which means we need a looser matching: fact base name CONTAINS or ENDS WITH the dim base name

**Simplest correct approach per requirements:** Use the reference notebook's approach adapted for our prefix scheme. The `infer_relationships` function takes an optional `role_separator` parameter (default `None`). When provided, it's used to extract base keys for role-playing matching:
- Without separator: exact base name match only
- With separator (e.g., `"__"`): `strip_prefix(col)[0:first_separator_pos]` is the base key

Tests should cover both modes.

**REVISED TEST PLAN:**

REQ-06 tests (basic matching -- base names equal after prefix stripping):
- `test_basic_match_equal_base_names`: FK_CustomerID -> CustomerID matches SK_CustomerID -> CustomerID
- `test_no_match_different_base_names`: FK_OrderID -> OrderID does not match SK_CustomerID -> CustomerID
- `test_multiple_dims_matched`: Fact with FK_CustomerID and FK_ProductID matches both DimCustomer (SK_CustomerID) and DimProduct (SK_ProductID)
- `test_cross_schema_matching`: Fact in "fact" schema matches dim in "dim" schema
- `test_only_facts_match_to_dims`: Dim-to-dim and fact-to-fact not matched

REQ-07 + REQ-08 tests (role-playing dimensions):
- `test_role_playing_two_columns_same_dimension`: Fact has FK_CustomerID and FK_CustomerID_BillTo. Dim has SK_CustomerID. With direct matching, only FK_CustomerID matches (base name equality). This isn't role-playing. **Hmm.**

Let me re-read the requirement: "Role-playing dimensions are detected when the same dimension is referenced multiple times from a single fact with different key column prefixes." The key phrase is "different key column prefixes" -- but our key prefixes are `SK_`, `FK_`, etc. So "different key column prefixes" means different prefixed COLUMNS, not different prefixes. The role-playing happens because a fact has MULTIPLE FK columns that all resolve to the SAME dimension.

For this to work with simple prefix stripping and equality, the fact table must have multiple columns with the SAME base name after stripping. But column names are unique. So the fact must have: `FK_CustomerID` AND... another column with base name `CustomerID`? That's impossible if both use `FK_` prefix.

**The answer is in the reference notebook.** It uses `_hk__customer` as dim PK and `_hk__customer` as one fact FK (exact match) plus `_hk__customer__bill_to` as another fact FK (role-playing, base key extraction matches `_hk__customer`). The notebook's `extract_base_key` extracts `_hk__customer` from `_hk__customer__bill_to` by taking prefix + first segment.

For a simpler prefix like `ID_`, role-playing would work with underscore segmentation. E.g., dim has `ID_Customer` (base: `Customer`), fact has `ID_Customer` (exact match) and `ID_Customer_BillTo` (role-playing -- base key `Customer` after taking first segment before `_`).

But wait, that would incorrectly segment `ID_CustomerID` into base key `CustomerID`, which is fine, but `ID_Customer_Region` might incorrectly become `Customer` when the actual dim is `ID_CustomerRegion`.

This is getting complex. Let me step back and look at what the REQUIREMENTS actually say:

- REQ-06: "Infer star-schema relationships (fact *:1 dimension) via matching key columns" -- matching KEY columns. The simplest interpretation: fact column and dim column have the same base name after stripping prefixes.
- REQ-07: "Support role-playing dimensions (same dim referenced multiple times with different roles)" -- same dim, multiple references from one fact.
- REQ-09: "Support exact-match prefixes that bypass role-playing pattern" -- exact match = column name IS a prefix.

The reference notebook implements role-playing via the double-underscore convention. Our library should support a similar mechanism but let the user configure it. The simplest approach that satisfies all requirements:

**Matching algorithm:**
1. For each dimension, get its single key column and strip the prefix to get `dim_base`.
2. For each fact key column:
   a. If `is_exact_match(col, prefixes)` (REQ-09): skip role-playing, find dim with matching exact column name -> always active
   b. Strip prefix to get `fact_base`. If `fact_base == dim_base`: direct match
   c. If no direct match, check if `fact_base` starts with `dim_base`: role-playing match (the remaining suffix is the "role")
3. Group by (from_table, to_table). If multiple: first (sorted by from_column) is active, rest inactive (REQ-08)

This is clean and handles all cases. "starts with" is the key insight for role-playing detection.

**FINAL TEST LIST:**

Helper function tests (strip_prefix, is_exact_match): as listed above.

REQ-06 -- Basic inference:
- `test_single_relationship`: 1 fact, 1 dim, matching base names -> 1 active relationship
- `test_multiple_dimensions`: 1 fact, 2 dims, matching keys -> 2 active relationships
- `test_no_match_returns_empty`: fact key doesn't match any dim -> empty
- `test_unclassified_ignored`: unclassified tables produce no relationships
- `test_empty_input`: no tables -> empty tuple
- `test_fact_to_fact_no_relationship`: two facts don't create relationships between each other
- `test_cross_schema_relationship`: fact in schema A matches dim in schema B

REQ-07 -- Role-playing detection:
- `test_role_playing_detected`: Fact has `FK_CustomerID` (base: `CustomerID`) and `FK_CustomerID_BillTo` (base: `CustomerID_BillTo`). Dim has `SK_CustomerID` (base: `CustomerID`). `CustomerID` matches directly. `CustomerID_BillTo` starts with `CustomerID` -- role-playing match. Two relationships to same dim.

REQ-08 -- Active/inactive marking:
- `test_first_role_playing_active_rest_inactive`: From the role-playing test above, sorted by from_column: `FK_CustomerID` < `FK_CustomerID_BillTo`, so first is active, second is inactive.
- `test_single_relationship_always_active`: Non-role-playing relationship is always active.
- `test_deterministic_ordering`: Same inputs always produce same active/inactive assignment.

REQ-09 -- Exact-match bypass:
- `test_exact_match_bypass_role_playing`: Fact has column named exactly `FK_` (matches prefix `FK_` exactly). This bypasses role-playing detection and is always active. (Note: exact match columns can't really match a dimension since stripped base is empty. Per research Open Question 1, skip these as they produce no base name to match against.)
- `test_exact_match_not_grouped_for_role_playing`: An exact-match column and a normal column to the same dim don't count as role-playing pair.

Actually, re-reading REQ-09 and the research: "exact-match prefixes bypass role-playing detection (the key column name matches a prefix exactly, no suffix stripping)." This means the column name IS the prefix. After stripping, the base name is empty string. It can't match any dimension. So exact-match columns simply produce NO relationships and don't interfere with role-playing grouping. Test:
- `test_exact_match_produces_no_relationship`: Column named `FK_` with prefix `FK_` produces no relationship (empty base name can't match)
- `test_exact_match_excluded_from_role_playing_grouping`: A fact with `FK_`, `FK_CustomerID`, `FK_CustomerID_BillTo` and a dim with `SK_CustomerID`. The `FK_` is excluded. The remaining two produce role-playing (first active, second inactive). The `FK_` does NOT count as a third relationship.

Deterministic output:
- `test_relationships_sorted_deterministically`: Output tuple is sorted by (from_table, from_column, to_table, to_column)
- `test_relationship_ids_are_deterministic`: Same inputs produce same UUID IDs via uuid_gen
  </action>
  <verify>
Run `make test` -- all NEW tests should FAIL (RED phase). Existing tests should still pass. Run `make typecheck` to verify stub imports work. Run `make lint` to verify code style.

```bash
python -m pytest tests/schema/test_relationships.py -v 2>&1 | head -60
# Expect: all tests FAIL with NotImplementedError
make check
# Expect: lint and typecheck pass, tests fail only on new tests
```
  </verify>
  <done>
- `tests/schema/test_relationships.py` exists with 15+ tests covering REQ-06, REQ-07, REQ-08, REQ-09
- `Relationship` dataclass exists in `domain/types.py` (frozen, slots, correct fields and defaults)
- Stub functions exist in `schema/relationships.py` (raise NotImplementedError)
- All new tests fail with NotImplementedError (RED)
- All existing tests still pass
- `make lint` and `make typecheck` pass
  </done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Implement relationship inference to pass all tests</name>
  <files>
    src/semantic_model_generator/schema/relationships.py
    src/semantic_model_generator/schema/__init__.py
  </files>
  <action>
Implement the relationship inference functions in `src/semantic_model_generator/schema/relationships.py` to make all tests pass.

**`strip_prefix(column_name, key_prefixes) -> str | None`:**
- Iterate `key_prefixes` in order
- If `column_name.startswith(prefix)`: return `column_name[len(prefix):]`
- If no prefix matches: return `None`
- Note: if column name equals prefix exactly, returns empty string `""`

**`is_exact_match(column_name, key_prefixes) -> bool`:**
- Return `column_name in key_prefixes`
- Simple membership test

**`infer_relationships(tables, classifications, key_prefixes) -> tuple[Relationship, ...]`:**

Algorithm:
1. Separate tables into facts and dimensions using the `classifications` dict
2. For each dimension, find its single key column (the one column matching any prefix) and compute `dim_base = strip_prefix(dim_key_col, key_prefixes)`
3. Build a lookup: `dim_base -> (dim_qualified_name, dim_key_col_name)`
4. For each fact table, for each key column in the fact:
   a. If `is_exact_match(col.name, key_prefixes)`: skip (REQ-09, no base name to match)
   b. Compute `fact_base = strip_prefix(col.name, key_prefixes)`
   c. If `fact_base is None`: skip
   d. Try direct match: if `fact_base` equals any `dim_base`, create relationship
   e. If no direct match, try role-playing match: if `fact_base` starts with any `dim_base` (and the character after `dim_base` in `fact_base` is `_` or end-of-string to avoid false positives like `CustomerRegion` matching `Customer`), create relationship
5. All relationships initially created with `is_active=True`
6. Apply role-playing detection: group by `(from_table, to_table)`. For groups with 2+ relationships:
   - Sort by `from_column` name (deterministic ordering)
   - First remains `is_active=True`
   - Rest get recreated with `is_active=False` (frozen dataclass, must create new instances)
7. Sort final output by `(from_table, from_column, to_table, to_column)` for deterministic output
8. Return as tuple

**Relationship ID generation:**
Use `generate_deterministic_uuid("relationship", f"{from_table}.{from_column}->{to_table}.{to_column}")` following the pattern from uuid_gen.py and the research recommendation.

**Role-playing matching detail:**
For the "starts with" check to avoid false positives, require that after the dim_base portion of fact_base, the next character (if any) is an underscore `_` or the string is at the exact boundary. This prevents `CustomerRegion` from matching dim base `Customer` while allowing `Customer_BillTo` to match.

Example: dim_base = "CustomerID", fact_base = "CustomerID_BillTo"
- fact_base.startswith("CustomerID") = True
- fact_base[len("CustomerID")] = "_" -> valid role-playing match

Example: dim_base = "Customer", fact_base = "CustomerRegion"
- fact_base.startswith("Customer") = True
- fact_base[len("Customer")] = "R" (not "_") -> NOT a match

**Update `schema/__init__.py`:**
Add exports for `infer_relationships` and the `Relationship` type:
```python
from semantic_model_generator.schema.relationships import infer_relationships
```

Also update `domain/types.py` exports if needed (Relationship should be importable from domain.types).

**Type annotations:**
- All functions must have complete type annotations for mypy strict mode
- Use `collections.abc.Sequence` for input sequences (per project pattern)
- Return `tuple[Relationship, ...]` for immutable output
  </action>
  <verify>
```bash
python -m pytest tests/schema/test_relationships.py -v
# Expect: ALL tests PASS (GREEN phase)

make check
# Expect: lint + typecheck + all tests pass
```
  </verify>
  <done>
- All tests in `test_relationships.py` pass (GREEN)
- `make check` passes (lint + typecheck + all tests)
- `strip_prefix` correctly strips first matching prefix
- `is_exact_match` correctly detects exact prefix matches
- `infer_relationships` correctly infers fact-to-dim relationships (REQ-06)
- Role-playing dimensions detected and grouped (REQ-07)
- First role-playing active, rest inactive (REQ-08)
- Exact-match prefixes bypassed (REQ-09)
- Output is deterministically ordered and UUIDs are stable
- `schema/__init__.py` exports `infer_relationships`
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **REQ-06 verified:** `test_single_relationship`, `test_multiple_dimensions`, `test_cross_schema_relationship` prove fact-to-dim matching works
2. **REQ-07 verified:** `test_role_playing_detected` proves multiple references to same dim are detected
3. **REQ-08 verified:** `test_first_role_playing_active_rest_inactive`, `test_deterministic_ordering` prove active/inactive marking
4. **REQ-09 verified:** `test_exact_match_produces_no_relationship`, `test_exact_match_excluded_from_role_playing_grouping` prove exact-match bypass
5. **Determinism verified:** `test_relationships_sorted_deterministically`, `test_relationship_ids_are_deterministic`
6. **Quality gates:** `make check` passes (lint + typecheck + all tests)
</verification>

<success_criteria>
- `make check` passes with zero warnings
- All 15+ new tests in `test_relationships.py` pass
- All existing tests (138+) continue to pass
- `Relationship` dataclass is frozen and immutable
- `infer_relationships` is a pure function with no side effects
- Output is deterministic (same inputs -> same output)
</success_criteria>

<output>
After completion, create `.planning/phases/04-relationship-inference/04-01-SUMMARY.md`
</output>
