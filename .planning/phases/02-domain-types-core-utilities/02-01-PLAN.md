---
phase: 02-domain-types-core-utilities
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/semantic_model_generator/domain/__init__.py
  - src/semantic_model_generator/domain/types.py
  - src/semantic_model_generator/utils/__init__.py
  - src/semantic_model_generator/utils/type_mapping.py
  - tests/domain/__init__.py
  - tests/domain/test_types.py
  - tests/utils/__init__.py
  - tests/utils/test_type_mapping.py
autonomous: true

must_haves:
  truths:
    - "Every SQL Server data type used in Fabric warehouses maps to a valid TMDL data type"
    - "TmdlDataType enum values match TMDL specification data type strings exactly"
    - "Type mapping handles case-insensitive SQL type input"
    - "Unsupported SQL types raise ValueError with helpful message listing supported types"
    - "Domain types are immutable (frozen dataclass) and memory-efficient (slots)"
  artifacts:
    - path: "src/semantic_model_generator/domain/types.py"
      provides: "Frozen dataclasses for ColumnMetadata, TableMetadata, TmdlDataType StrEnum"
      contains: "frozen=True, slots=True"
      exports: ["ColumnMetadata", "TableMetadata", "TmdlDataType"]
    - path: "src/semantic_model_generator/utils/type_mapping.py"
      provides: "SQL-to-TMDL type mapping function and lookup dict"
      exports: ["map_sql_type_to_tmdl", "SQL_TO_TMDL_TYPE"]
    - path: "tests/domain/test_types.py"
      provides: "Tests for domain type immutability, validation, equality"
    - path: "tests/utils/test_type_mapping.py"
      provides: "Tests for all SQL-to-TMDL type mappings including edge cases"
  key_links:
    - from: "src/semantic_model_generator/utils/type_mapping.py"
      to: "src/semantic_model_generator/domain/types.py"
      via: "imports TmdlDataType enum"
      pattern: "from semantic_model_generator\\.domain\\.types import TmdlDataType"
---

<objective>
Create immutable domain types (frozen dataclasses) and TmdlDataType enum, then implement SQL-to-TMDL type mapping using TDD. This establishes the core data structures and type conversion logic that every downstream phase depends on.

Purpose: Domain types define the shape of all data flowing through the system. Type mapping converts warehouse metadata into TMDL-compatible types. Both must be correct, tested, and immutable.
Output: Tested domain/types.py module with frozen dataclasses + TmdlDataType enum, tested utils/type_mapping.py with complete SQL-to-TMDL conversion.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-domain-types-core-utilities/02-RESEARCH.md
@pyproject.toml
@src/semantic_model_generator/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD domain types -- frozen dataclasses and TmdlDataType enum</name>
  <files>
    src/semantic_model_generator/domain/__init__.py
    src/semantic_model_generator/domain/types.py
    tests/domain/__init__.py
    tests/domain/test_types.py
  </files>
  <action>
FIRST: Create the phase branch from main:
```bash
git checkout main && git checkout -b gsd/phase-2-domain-types-core-utilities
```

Then create the directory structure:
- src/semantic_model_generator/domain/__init__.py (empty, just docstring)
- tests/domain/__init__.py (empty)

RED phase -- Write tests/domain/test_types.py FIRST with these test cases:

1. TmdlDataType enum:
   - Test that TmdlDataType is a StrEnum subclass
   - Test that TmdlDataType.INT64 == "int64" (string comparison works)
   - Test that TmdlDataType.DOUBLE == "double"
   - Test that TmdlDataType.BOOLEAN == "boolean"
   - Test that TmdlDataType.STRING == "string"
   - Test that TmdlDataType.DATETIME == "dateTime" (note camelCase)
   - Test that TmdlDataType.DECIMAL == "decimal"
   - Test that TmdlDataType.BINARY == "binary"
   - Test that all 7 members exist (len(TmdlDataType) == 7)

2. ColumnMetadata frozen dataclass:
   - Test construction with required fields (name, sql_type, is_nullable, ordinal_position)
   - Test optional fields default to None (max_length, numeric_precision, numeric_scale)
   - Test frozen: assigning to col.name raises FrozenInstanceError (use dataclasses.FrozenInstanceError)
   - Test equality: two instances with same values are equal
   - Test hashable: can be added to a set
   - Test __post_init__ validation: empty name raises ValueError
   - Test __post_init__ validation: ordinal_position < 1 raises ValueError

3. TableMetadata frozen dataclass:
   - Test construction with required fields (schema_name, table_name, columns as tuple of ColumnMetadata)
   - Test frozen: assigning raises FrozenInstanceError
   - Test equality and hashability
   - Test columns is a tuple (not list -- enforces immutability of collection)

Run tests -- they MUST fail (no implementation yet). Commit: "test(02-01): add failing tests for domain types and TmdlDataType enum"

GREEN phase -- Create src/semantic_model_generator/domain/types.py:

```python
from dataclasses import dataclass
from enum import StrEnum

class TmdlDataType(StrEnum):
    """TMDL tabular model data types."""
    INT64 = "int64"
    DOUBLE = "double"
    BOOLEAN = "boolean"
    STRING = "string"
    DATETIME = "dateTime"
    DECIMAL = "decimal"
    BINARY = "binary"

@dataclass(frozen=True, slots=True)
class ColumnMetadata:
    """Immutable metadata for a warehouse column."""
    name: str
    sql_type: str
    is_nullable: bool
    ordinal_position: int
    max_length: int | None = None
    numeric_precision: int | None = None
    numeric_scale: int | None = None

    def __post_init__(self) -> None:
        if not self.name:
            raise ValueError("Column name cannot be empty")
        if self.ordinal_position < 1:
            raise ValueError("Ordinal position must be >= 1")

@dataclass(frozen=True, slots=True)
class TableMetadata:
    """Immutable metadata for a warehouse table."""
    schema_name: str
    table_name: str
    columns: tuple[ColumnMetadata, ...]
```

Update domain/__init__.py to re-export: ColumnMetadata, TableMetadata, TmdlDataType.

Run tests -- they MUST pass. Run `make check` to confirm lint + typecheck + test all pass.
Commit: "feat(02-01): implement domain types and TmdlDataType enum"

IMPORTANT style notes per REQ-22: No classes beyond frozen dataclasses and StrEnum. These ARE the exception noted in the requirement ("no classes unless strictly necessary"). Dataclasses and enums are the Pythonic way to define value types.
  </action>
  <verify>
    1. `make test` passes with all domain type tests green
    2. `make check` passes (lint + typecheck + test)
    3. `python -c "from semantic_model_generator.domain.types import TmdlDataType; assert TmdlDataType.INT64 == 'int64'"` succeeds
    4. `python -c "from semantic_model_generator.domain.types import ColumnMetadata; c = ColumnMetadata('x', 'int', False, 1); c.name = 'y'"` raises FrozenInstanceError
  </verify>
  <done>
    TmdlDataType enum has 7 members matching TMDL spec strings exactly. ColumnMetadata and TableMetadata are frozen, slotted, hashable, and validate invariants. All tests pass including immutability and validation edge cases.
  </done>
</task>

<task type="auto">
  <name>Task 2: TDD SQL-to-TMDL type mapping</name>
  <files>
    src/semantic_model_generator/utils/__init__.py
    src/semantic_model_generator/utils/type_mapping.py
    tests/utils/__init__.py
    tests/utils/test_type_mapping.py
  </files>
  <action>
Create directory structure:
- src/semantic_model_generator/utils/__init__.py (empty, just docstring)
- tests/utils/__init__.py (empty)

RED phase -- Write tests/utils/test_type_mapping.py FIRST with these test cases:

1. Exact mapping tests (one test per SQL type):
   - "bit" -> TmdlDataType.BOOLEAN
   - "smallint" -> TmdlDataType.INT64
   - "int" -> TmdlDataType.INT64
   - "bigint" -> TmdlDataType.INT64
   - "decimal" -> TmdlDataType.DECIMAL
   - "numeric" -> TmdlDataType.DECIMAL
   - "float" -> TmdlDataType.DOUBLE
   - "real" -> TmdlDataType.DOUBLE
   - "char" -> TmdlDataType.STRING
   - "varchar" -> TmdlDataType.STRING
   - "date" -> TmdlDataType.DATETIME
   - "datetime2" -> TmdlDataType.DATETIME
   - "time" -> TmdlDataType.DATETIME
   - "varbinary" -> TmdlDataType.BINARY
   - "uniqueidentifier" -> TmdlDataType.BINARY
   Use pytest.mark.parametrize for all 15 mappings.

2. Case insensitivity:
   - "VARCHAR" -> TmdlDataType.STRING
   - "Int" -> TmdlDataType.INT64
   - "BIGINT" -> TmdlDataType.INT64

3. Whitespace handling:
   - " varchar " (leading/trailing spaces) -> TmdlDataType.STRING
   - "  int  " -> TmdlDataType.INT64

4. Error cases:
   - "unsupported_type" raises ValueError
   - "" (empty string) raises ValueError
   - ValueError message contains "Supported types:" with list of valid types

5. SQL_TO_TMDL_TYPE dict:
   - Test dict has exactly 15 entries
   - Test all values are TmdlDataType members

Run tests -- they MUST fail. Commit: "test(02-01): add failing tests for SQL-to-TMDL type mapping"

GREEN phase -- Create src/semantic_model_generator/utils/type_mapping.py:

Implement the SQL_TO_TMDL_TYPE dict and map_sql_type_to_tmdl() function exactly as shown in 02-RESEARCH.md Pattern 3. Import TmdlDataType from semantic_model_generator.domain.types.

The function signature:
```python
def map_sql_type_to_tmdl(sql_type: str) -> TmdlDataType:
```

Key implementation details:
- Normalize input: sql_type.lower().strip()
- Empty string check: raise ValueError before lookup
- Missing key: raise ValueError with sorted list of supported types
- Return type is TmdlDataType (not str)

Update utils/__init__.py to re-export: map_sql_type_to_tmdl, SQL_TO_TMDL_TYPE.

Run tests -- they MUST pass. Run `make check` to confirm all green.
Commit: "feat(02-01): implement SQL-to-TMDL type mapping"
  </action>
  <verify>
    1. `make test` passes with all type mapping tests green
    2. `make check` passes (lint + typecheck + test)
    3. `python -c "from semantic_model_generator.utils.type_mapping import map_sql_type_to_tmdl; assert map_sql_type_to_tmdl('varchar') == 'string'"` succeeds
    4. `python -c "from semantic_model_generator.utils.type_mapping import map_sql_type_to_tmdl; map_sql_type_to_tmdl('unsupported')"` raises ValueError
  </verify>
  <done>
    All 15 SQL Server types used in Fabric warehouses map to correct TMDL data types. Case-insensitive and whitespace-tolerant input handling works. Unsupported types produce clear ValueError with list of supported types. map_sql_type_to_tmdl imports TmdlDataType from domain.types (key link verified).
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `make check` passes with zero errors
2. All domain type tests pass (immutability, validation, equality, hashability)
3. All type mapping tests pass (all 15 SQL types, case handling, error cases)
4. `mypy src/` passes in strict mode (frozen dataclasses + StrEnum are mypy-compatible)
5. Domain types are importable: `from semantic_model_generator.domain.types import ColumnMetadata, TableMetadata, TmdlDataType`
6. Type mapping is importable: `from semantic_model_generator.utils.type_mapping import map_sql_type_to_tmdl`
</verification>

<success_criteria>
- TmdlDataType enum has exactly 7 members with correct TMDL string values
- ColumnMetadata and TableMetadata are frozen, slotted, hashable
- map_sql_type_to_tmdl correctly maps all 15 SQL types to TMDL types
- All tests written BEFORE implementation (TDD commits prove this)
- make check passes (lint + typecheck + test)
- Zero external dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/02-domain-types-core-utilities/02-01-SUMMARY.md`
</output>
