---
phase: 02-domain-types-core-utilities
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/semantic_model_generator/utils/uuid_gen.py
  - src/semantic_model_generator/utils/identifiers.py
  - src/semantic_model_generator/utils/whitespace.py
  - tests/utils/test_uuid_gen.py
  - tests/utils/test_identifiers.py
  - tests/utils/test_whitespace.py
autonomous: true

must_haves:
  truths:
    - "Calling the UUID generator twice with the same inputs produces identical UUIDs (deterministic via uuid5)"
    - "Different object types with same name produce different UUIDs (no collisions)"
    - "Identifiers containing special characters (spaces, dots, quotes) are correctly single-quoted with escaped internal quotes"
    - "Simple identifiers without special characters pass through unquoted"
    - "TMDL output uses tabs for indentation (not spaces) and passes whitespace validation"
    - "Whitespace validator returns structured error list (not exceptions) for composability"
  artifacts:
    - path: "src/semantic_model_generator/utils/uuid_gen.py"
      provides: "Deterministic UUID generation via uuid5 with project namespace"
      exports: ["generate_deterministic_uuid", "SEMANTIC_MODEL_NAMESPACE"]
    - path: "src/semantic_model_generator/utils/identifiers.py"
      provides: "TMDL identifier quoting and unquoting"
      exports: ["quote_tmdl_identifier", "unquote_tmdl_identifier"]
    - path: "src/semantic_model_generator/utils/whitespace.py"
      provides: "TMDL whitespace validation and indentation helper"
      exports: ["validate_tmdl_indentation", "indent_tmdl", "IndentationError"]
    - path: "tests/utils/test_uuid_gen.py"
      provides: "Tests for determinism, namespace isolation, normalization"
    - path: "tests/utils/test_identifiers.py"
      provides: "Tests for quoting rules, escaping, round-trip, edge cases"
    - path: "tests/utils/test_whitespace.py"
      provides: "Tests for tab validation, space detection, indent helper"
  key_links:
    - from: "src/semantic_model_generator/utils/uuid_gen.py"
      to: "uuid (stdlib)"
      via: "uuid.uuid5() with project namespace constant"
      pattern: "uuid\\.uuid5\\(SEMANTIC_MODEL_NAMESPACE"
    - from: "src/semantic_model_generator/utils/identifiers.py"
      to: "re (stdlib)"
      via: "regex for special character detection"
      pattern: "re\\.search.*\\[.*\\\\s"
    - from: "src/semantic_model_generator/utils/whitespace.py"
      to: "typing (stdlib)"
      via: "NamedTuple for structured error type"
      pattern: "class IndentationError.*NamedTuple"
---

<objective>
Implement three independent pure-function utility modules using TDD: deterministic UUID generation, TMDL identifier quoting, and TMDL whitespace validation. These are the building blocks used by every downstream phase for generating correct TMDL output.

Purpose: UUID generation ensures stable IDs across regenerations (REQ-12). Identifier quoting ensures names with special characters produce valid TMDL (REQ-30). Whitespace validation ensures tab-only indentation per TMDL spec (REQ-30).
Output: Three tested utility modules in src/semantic_model_generator/utils/, each with comprehensive test coverage.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-domain-types-core-utilities/02-RESEARCH.md
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD deterministic UUID generation</name>
  <files>
    src/semantic_model_generator/utils/uuid_gen.py
    tests/utils/test_uuid_gen.py
  </files>
  <action>
NOTE: If branch gsd/phase-2-domain-types-core-utilities does not exist yet (Plan 01 hasn't run), create it:
```bash
git checkout main && git checkout -b gsd/phase-2-domain-types-core-utilities
```
If it already exists, check it out:
```bash
git checkout gsd/phase-2-domain-types-core-utilities
```

Ensure tests/utils/__init__.py and src/semantic_model_generator/utils/__init__.py exist (create if Plan 01 hasn't run yet -- empty files with docstrings).

RED phase -- Write tests/utils/test_uuid_gen.py FIRST with these test cases:

1. Determinism:
   - generate_deterministic_uuid("table", "Sales") called twice returns identical UUID
   - generate_deterministic_uuid("column", "Sales.Amount") called twice returns identical UUID

2. Different inputs produce different UUIDs:
   - generate_deterministic_uuid("table", "Sales") != generate_deterministic_uuid("table", "Customers")
   - generate_deterministic_uuid("table", "Sales") != generate_deterministic_uuid("column", "Sales") (different object type, same name)

3. Input normalization:
   - generate_deterministic_uuid("table", "Sales") == generate_deterministic_uuid("table", "Sales ") (trailing space stripped)
   - generate_deterministic_uuid("table", "Sales") == generate_deterministic_uuid("table", " Sales") (leading space stripped)
   - generate_deterministic_uuid("TABLE", "Sales") == generate_deterministic_uuid("table", "Sales") (object_type is case-normalized)

4. Case preservation for object_name:
   - generate_deterministic_uuid("table", "Sales") != generate_deterministic_uuid("table", "sales") (name case matters -- source system is case-sensitive)

5. Return type:
   - Result is uuid.UUID instance
   - Result version is 5 (uuid5)

6. Namespace constant:
   - SEMANTIC_MODEL_NAMESPACE is a uuid.UUID instance
   - SEMANTIC_MODEL_NAMESPACE is not a well-known namespace (not NAMESPACE_DNS, NAMESPACE_URL, etc.)

7. Edge cases:
   - Empty object_type raises ValueError
   - Empty object_name raises ValueError

Run tests -- they MUST fail. Commit: "test(02-02): add failing tests for deterministic UUID generation"

GREEN phase -- Create src/semantic_model_generator/utils/uuid_gen.py:

```python
"""Deterministic UUID generation for semantic model objects."""

import uuid

# Project-specific namespace for uuid5 generation.
# Generated once via uuid.uuid4(), committed as constant.
# All semantic model UUIDs are derived from this namespace.
SEMANTIC_MODEL_NAMESPACE = uuid.UUID("b8a7d3f2-6c1e-4a59-9d2b-8f3e7c5a1d04")


def generate_deterministic_uuid(object_type: str, object_name: str) -> uuid.UUID:
    """Generate a stable UUID for a semantic model object.

    Uses uuid5 (SHA-1) with a project-specific namespace to ensure:
    - Same inputs always produce the same UUID
    - Different inputs produce different UUIDs
    - UUIDs are stable across regenerations (REQ-12)

    Args:
        object_type: Type of object (e.g., "table", "column", "relationship").
            Normalized to lowercase, stripped of whitespace.
        object_name: Fully qualified name of object (e.g., "Sales", "Sales.Amount").
            Stripped of whitespace but case is preserved (source systems may be case-sensitive).

    Returns:
        Deterministic UUID based on object type and name.

    Raises:
        ValueError: If object_type or object_name is empty after stripping.
    """
    normalized_type = object_type.strip().lower()
    normalized_name = object_name.strip()

    if not normalized_type:
        raise ValueError("object_type cannot be empty")
    if not normalized_name:
        raise ValueError("object_name cannot be empty")

    composite_name = f"{normalized_type}:{normalized_name}"
    return uuid.uuid5(SEMANTIC_MODEL_NAMESPACE, composite_name)
```

Update utils/__init__.py to also export generate_deterministic_uuid and SEMANTIC_MODEL_NAMESPACE (add to existing exports if Plan 01 already populated it).

Run tests -- they MUST pass. Run `make check`.
Commit: "feat(02-02): implement deterministic UUID generation"
  </action>
  <verify>
    1. `make test -k test_uuid_gen` passes with all UUID tests green
    2. `make check` passes
    3. `python -c "from semantic_model_generator.utils.uuid_gen import generate_deterministic_uuid; u1 = generate_deterministic_uuid('table', 'Sales'); u2 = generate_deterministic_uuid('table', 'Sales'); assert u1 == u2; print('Deterministic:', u1)"` succeeds
  </verify>
  <done>
    UUID generator produces identical output for identical inputs. Different object types with same name produce different UUIDs. Input normalization handles whitespace and type casing. Object name case is preserved. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: TDD TMDL identifier quoting and whitespace validation</name>
  <files>
    src/semantic_model_generator/utils/identifiers.py
    src/semantic_model_generator/utils/whitespace.py
    tests/utils/test_identifiers.py
    tests/utils/test_whitespace.py
  </files>
  <action>
RED phase -- Write BOTH test files FIRST:

**tests/utils/test_identifiers.py** test cases:

1. No quoting needed:
   - "Sales" -> "Sales" (simple alphanumeric)
   - "DimProduct" -> "DimProduct"
   - "FactSales" -> "FactSales"

2. Quoting triggered by special characters:
   - "Product Name" -> "'Product Name'" (whitespace)
   - "Table.Column" -> "'Table.Column'" (dot)
   - "Key=Value" -> "'Key=Value'" (equals)
   - "Type:Name" -> "'Type:Name'" (colon)
   - "Customer's Choice" -> "'Customer''s Choice'" (single quote -- escaped by doubling)

3. Multiple special characters:
   - "My Table.Col Name" -> "'My Table.Col Name'" (space + dot)
   - "It's a.test" -> "'It''s a.test'" (quote + dot + space)

4. Unquoting (round-trip):
   - unquote_tmdl_identifier("Sales") -> "Sales" (no quotes to remove)
   - unquote_tmdl_identifier("'Product Name'") -> "Product Name"
   - unquote_tmdl_identifier("'Customer''s Choice'") -> "Customer's Choice"

5. Round-trip invariant:
   - For each test name: unquote(quote(name)) == name
   Use parametrize with: "Sales", "Product Name", "Customer's Choice", "Table.Column"

6. Edge cases:
   - Empty string raises ValueError
   - Tab character triggers quoting: "Name\tExtra" -> "'Name\tExtra'"

**tests/utils/test_whitespace.py** test cases:

1. Valid TMDL (tab indentation):
   - "table Sales\n\tcolumn Name" -> empty error list
   - "\t\tcolumn deep" -> empty error list
   - "no indent line" -> empty error list (no indentation = valid)
   - "" -> empty error list (empty content)
   - "\n\n\n" -> empty error list (blank lines)

2. Invalid TMDL (space indentation):
   - "  column Name" -> 1 error, line 1, mentions "2 leading space(s)"
   - "table Sales\n  column Name" -> 1 error, line 2
   - "  line1\n  line2" -> 2 errors (one per line)
   - "\ttab line\n  space line" -> 1 error on line 2 only (tab line is fine)

3. IndentationError structure:
   - Error has line_number (int), message (str), line_content (str)
   - line_content is truncated to first 50 chars

4. indent_tmdl helper:
   - indent_tmdl(0) -> "" (empty string)
   - indent_tmdl(1) -> "\t"
   - indent_tmdl(2) -> "\t\t"
   - indent_tmdl(3) -> "\t\t\t"
   - indent_tmdl(-1) raises ValueError

Run ALL tests -- they MUST fail. Commit: "test(02-02): add failing tests for identifier quoting and whitespace validation"

GREEN phase -- Create both implementation files:

**src/semantic_model_generator/utils/identifiers.py:**
Implement quote_tmdl_identifier() and unquote_tmdl_identifier() as pure functions.
- Use `re.search(r"[\s.=:']", identifier)` to detect need for quoting
- Escape internal quotes: `identifier.replace("'", "''")`
- Wrap in single quotes: `f"'{escaped}'"`
- Unquote: strip outer quotes, unescape doubled quotes
- Raise ValueError on empty input

**src/semantic_model_generator/utils/whitespace.py:**
Implement validate_tmdl_indentation() and indent_tmdl() as pure functions.
- Use NamedTuple `IndentationError` with fields: line_number (int), message (str), line_content (str)
- NOTE: Name the NamedTuple `IndentationError` but be careful -- do NOT shadow the built-in IndentationError. Use a module-qualified import pattern or name it `TmdlIndentationError` to avoid confusion. DECISION: Name it `TmdlIndentationError` to be explicit and avoid shadowing.
- Iterate lines, check for leading spaces on non-empty lines
- indent_tmdl: return "\t" * level, validate level >= 0

Update utils/__init__.py to also export: quote_tmdl_identifier, unquote_tmdl_identifier, validate_tmdl_indentation, indent_tmdl, TmdlIndentationError.

Run tests -- they MUST pass. Run `make check`.
Commit: "feat(02-02): implement identifier quoting and whitespace validation"
  </action>
  <verify>
    1. `make test -k "test_identifiers or test_whitespace"` passes with all tests green
    2. `make check` passes (lint + typecheck + test)
    3. `python -c "from semantic_model_generator.utils.identifiers import quote_tmdl_identifier; assert quote_tmdl_identifier('Product Name') == \"'Product Name'\""` succeeds
    4. `python -c "from semantic_model_generator.utils.whitespace import validate_tmdl_indentation; errs = validate_tmdl_indentation('  bad indent'); assert len(errs) == 1"` succeeds
    5. `python -c "from semantic_model_generator.utils.whitespace import indent_tmdl; assert indent_tmdl(2) == '\t\t'"` succeeds
  </verify>
  <done>
    Identifiers with special characters (spaces, dots, equals, colons, quotes) are correctly quoted. Simple identifiers pass through unchanged. Quote escaping doubles internal single quotes. Round-trip quote/unquote preserves original string. Whitespace validator detects space indentation and returns structured errors. indent_tmdl produces correct tab strings. All tests pass with TDD commits proving test-first approach.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `make check` passes with zero errors
2. UUID determinism: same inputs -> same UUID, different inputs -> different UUID
3. Identifier quoting: special chars quoted, simple names unquoted, round-trip works
4. Whitespace validation: spaces detected as errors, tabs pass clean
5. All modules importable from semantic_model_generator.utils.*
6. Zero external dependencies (all stdlib: uuid, re, enum, dataclasses, typing)
7. All functions are pure (no side effects, no mutable state)
8. TDD commit history shows tests before implementation for each feature
</verification>

<success_criteria>
- generate_deterministic_uuid("table", "X") == generate_deterministic_uuid("table", "X") for any X
- quote_tmdl_identifier handles all 5 special character types correctly
- unquote_tmdl_identifier(quote_tmdl_identifier(name)) == name for all valid names
- validate_tmdl_indentation returns empty list for tab-indented content
- validate_tmdl_indentation returns non-empty list for space-indented content
- indent_tmdl(N) returns exactly N tab characters
- make check passes
- All tests written BEFORE implementation (TDD commits prove this)
</success_criteria>

<output>
After completion, create `.planning/phases/02-domain-types-core-utilities/02-02-SUMMARY.md`
</output>
