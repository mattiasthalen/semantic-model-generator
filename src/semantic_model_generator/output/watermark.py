"""Watermark generation, detection, atomic file writing, and WriteSummary."""

import json
import os
import tempfile
from dataclasses import dataclass
from datetime import UTC, datetime
from pathlib import Path


@dataclass(frozen=True, slots=True)
class WriteSummary:
    """Summary of file writing operations.

    Fields:
        written: Files that were created or overwritten (had watermark or didn't exist)
        skipped: Files that existed without watermark (manually maintained)
        unchanged: Files where new content is byte-identical to existing content
        output_path: Path to the output directory
    """

    written: tuple[str, ...]
    skipped: tuple[str, ...]
    unchanged: tuple[str, ...]
    output_path: Path


def generate_watermark_tmdl(version: str, timestamp: str | None = None) -> str:
    """Generate a TMDL watermark header with triple-slash comments.

    Args:
        version: Version string (e.g., "1.0.0")
        timestamp: ISO 8601 UTC timestamp (e.g., "2026-02-10T12:00:00Z").
                   If None, uses current UTC time.

    Returns:
        Multi-line triple-slash comment block with watermark
    """
    if timestamp is None:
        timestamp = datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ")

    return (
        f"/// Auto-generated by semantic-model-generator v{version}\n"
        f"/// Generated: {timestamp}\n"
        f"/// DO NOT EDIT - remove this header to protect from regeneration\n"
    )


def generate_watermark_json(version: str, timestamp: str | None = None) -> str:
    """Generate a JSON watermark comment field value.

    Args:
        version: Version string (e.g., "1.0.0")
        timestamp: ISO 8601 UTC timestamp (e.g., "2026-02-10T12:00:00Z").
                   If None, uses current UTC time.

    Returns:
        String value for _comment field in JSON
    """
    if timestamp is None:
        timestamp = datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ")

    return (
        f"Auto-generated by semantic-model-generator v{version} at {timestamp}. "
        f"DO NOT EDIT - remove this field to protect from regeneration."
    )


def add_watermark_to_content(
    filename: str,
    content: str,
    version: str,
    timestamp: str | None = None,
) -> str:
    """Add watermark to content based on file extension.

    For .tmdl files: prepends triple-slash watermark header
    For .json, .pbism, .platform files: inserts _comment field as first key
    For unknown extensions: prepends TMDL-style watermark as safe default

    Args:
        filename: Name of the file (used to determine format)
        content: Original content to watermark
        version: Version string for watermark
        timestamp: Optional explicit timestamp for deterministic output

    Returns:
        Content with watermark added
    """
    extension = Path(filename).suffix.lower()

    if extension == ".tmdl":
        watermark_header = generate_watermark_tmdl(version, timestamp)
        return watermark_header + content

    if extension in {".json", ".pbism", ".platform"}:
        # Parse existing JSON, insert _comment as first field, re-serialize
        parsed = json.loads(content)
        comment_value = generate_watermark_json(version, timestamp)

        # Create new dict with _comment first
        watermarked = {"_comment": comment_value}
        watermarked.update(parsed)

        return json.dumps(watermarked, indent=2)

    # Unknown extension: use TMDL-style watermark as safe default
    watermark_header = generate_watermark_tmdl(version, timestamp)
    return watermark_header + content


def is_auto_generated(content: str) -> bool:
    """Detect if content contains auto-generation watermark.

    Uses simple string containment check for "semantic-model-generator".

    Args:
        content: File content to check

    Returns:
        True if watermark detected, False otherwise
    """
    if not content:
        return False

    return "semantic-model-generator" in content


def write_file_atomically(path: Path, content: str) -> None:
    """Write file atomically using tempfile + os.replace pattern.

    Creates parent directories if needed. Uses same-filesystem temp file
    and atomic os.replace() for crash-safe writes. Writes with UTF-8
    encoding and LF newlines.

    Args:
        path: Target file path
        content: Content to write

    Raises:
        OSError: If write operation fails
    """
    # Create parent directories if needed
    path.parent.mkdir(parents=True, exist_ok=True)

    # Create temp file in same directory for same-filesystem guarantee
    fd, temp_path = tempfile.mkstemp(dir=path.parent, text=True)

    try:
        # Write content with UTF-8 encoding and LF newlines
        with os.fdopen(fd, "w", encoding="utf-8", newline="\n") as f:
            f.write(content)

        # Atomic swap
        os.replace(temp_path, path)
    except Exception:
        # Clean up temp file on error
        try:
            os.unlink(temp_path)
        except OSError:
            pass  # Temp file may not exist or already cleaned up
        raise
